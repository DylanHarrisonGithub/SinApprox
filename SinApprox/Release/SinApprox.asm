; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@DIAPNNHL@Accuracy?5Test?3?5?$AA@	; `string'
PUBLIC	??_C@_0BG@GEKGDBFL@horner?8s?5method?5c?$CL?$CL?3?5?$AA@ ; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_0BN@PCIHOKN@horner?8s?5method?5intrinsics?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BP@ODCOEDID@unrolled?5horner?8s?5method?5c?$CL?$CL?3?5?$AA@ ; `string'
PUBLIC	??_C@_0CG@CAPGOKJE@unrolled?5horner?8s?5method?5intrins@ ; `string'
PUBLIC	??_C@_0P@ICANGEBK@factored?5c?$CL?$CL?3?5?$AA@	; `string'
PUBLIC	??_C@_0BL@FPFKILKD@factored?5with?5intrinsics?3?5?$AA@ ; `string'
PUBLIC	??_C@_0N@EOIGBEKF@Time?5Trial?3?5?$AA@		; `string'
PUBLIC	??_C@_0P@LOMHEPNH@machine?5sin?$CIx?$CJ?$AA@	; `string'
PUBLIC	??_C@_0N@KBFONPHA@?5nanoseconds?$AA@		; `string'
PUBLIC	??_C@_06IEGNHKAC@time?3?5?$AA@			; `string'
PUBLIC	??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@	; `string'
PUBLIC	??_C@_0BE@IIJBFDGH@horner?8s?5method?5c?$CL?$CL?$AA@ ; `string'
PUBLIC	??_C@_0CC@IKFEIJOO@unrolled?5p4?5horners?5method?5in?5c?$CL@ ; `string'
PUBLIC	??_C@_0CC@DBFPCLAP@unrolled?5p8?5horners?5method?5in?5c?$CL@ ; `string'
PUBLIC	??_C@_0BI@BBMOCOEL@factored?5quartic?5in?5c?$CL?$CL?$AA@ ; `string'
PUBLIC	??_C@_0BE@GGKOCPJD@factored?5p_8?5in?5c?$CL?$CL?$AA@ ; `string'
PUBLIC	??_C@_0CE@KPFAJFKC@horner?8s?5method?5with?5asm?5intrins@ ; `string'
PUBLIC	??_C@_0CP@EBAENJH@unrolled?5p4?5horners?5method?5with?5@ ; `string'
PUBLIC	??_C@_0CP@LGOFLGFG@unrolled?5p8?5horners?5method?5with?5@ ; `string'
PUBLIC	??_C@_0CB@IJPEMKEN@factored?5quartic?5with?5intrinsics@ ; `string'
PUBLIC	??_C@_0BI@KNMALJAH@factored?5p_8?5intrinsics?$AA@ ; `string'
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp___Query_perf_counter:PROC
EXTRN	__imp___Query_perf_frequency:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BI@KNMALJAH@factored?5p_8?5intrinsics?$AA@
CONST	SEGMENT
??_C@_0BI@KNMALJAH@factored?5p_8?5intrinsics?$AA@ DB 'factored p_8 intrin'
	DB	'sics', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IJPEMKEN@factored?5quartic?5with?5intrinsics@
CONST	SEGMENT
??_C@_0CB@IJPEMKEN@factored?5quartic?5with?5intrinsics@ DB 'factored quar'
	DB	'tic with intrinsics', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LGOFLGFG@unrolled?5p8?5horners?5method?5with?5@
CONST	SEGMENT
??_C@_0CP@LGOFLGFG@unrolled?5p8?5horners?5method?5with?5@ DB 'unrolled p8'
	DB	' horners method with asm intrinsics', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EBAENJH@unrolled?5p4?5horners?5method?5with?5@
CONST	SEGMENT
??_C@_0CP@EBAENJH@unrolled?5p4?5horners?5method?5with?5@ DB 'unrolled p4 '
	DB	'horners method with asm intrinsics', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KPFAJFKC@horner?8s?5method?5with?5asm?5intrins@
CONST	SEGMENT
??_C@_0CE@KPFAJFKC@horner?8s?5method?5with?5asm?5intrins@ DB 'horner''s m'
	DB	'ethod with asm intrinsics', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGKOCPJD@factored?5p_8?5in?5c?$CL?$CL?$AA@
CONST	SEGMENT
??_C@_0BE@GGKOCPJD@factored?5p_8?5in?5c?$CL?$CL?$AA@ DB 'factored p_8 in '
	DB	'c++', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BBMOCOEL@factored?5quartic?5in?5c?$CL?$CL?$AA@
CONST	SEGMENT
??_C@_0BI@BBMOCOEL@factored?5quartic?5in?5c?$CL?$CL?$AA@ DB 'factored qua'
	DB	'rtic in c++', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DBFPCLAP@unrolled?5p8?5horners?5method?5in?5c?$CL@
CONST	SEGMENT
??_C@_0CC@DBFPCLAP@unrolled?5p8?5horners?5method?5in?5c?$CL@ DB 'unrolled'
	DB	' p8 horners method in c++', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IKFEIJOO@unrolled?5p4?5horners?5method?5in?5c?$CL@
CONST	SEGMENT
??_C@_0CC@IKFEIJOO@unrolled?5p4?5horners?5method?5in?5c?$CL@ DB 'unrolled'
	DB	' p4 horners method in c++', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IIJBFDGH@horner?8s?5method?5c?$CL?$CL?$AA@
CONST	SEGMENT
??_C@_0BE@IIJBFDGH@horner?8s?5method?5c?$CL?$CL?$AA@ DB 'horner''s method'
	DB	' c++', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@ DB 'ns/f(x): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEGNHKAC@time?3?5?$AA@
CONST	SEGMENT
??_C@_06IEGNHKAC@time?3?5?$AA@ DB 'time: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
CONST	SEGMENT
??_C@_0N@KBFONPHA@?5nanoseconds?$AA@ DB ' nanoseconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LOMHEPNH@machine?5sin?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@LOMHEPNH@machine?5sin?$CIx?$CJ?$AA@ DB 'machine sin(x)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EOIGBEKF@Time?5Trial?3?5?$AA@
CONST	SEGMENT
??_C@_0N@EOIGBEKF@Time?5Trial?3?5?$AA@ DB 'Time Trial: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FPFKILKD@factored?5with?5intrinsics?3?5?$AA@
CONST	SEGMENT
??_C@_0BL@FPFKILKD@factored?5with?5intrinsics?3?5?$AA@ DB 'factored with '
	DB	'intrinsics: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ICANGEBK@factored?5c?$CL?$CL?3?5?$AA@
CONST	SEGMENT
??_C@_0P@ICANGEBK@factored?5c?$CL?$CL?3?5?$AA@ DB 'factored c++: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CAPGOKJE@unrolled?5horner?8s?5method?5intrins@
CONST	SEGMENT
??_C@_0CG@CAPGOKJE@unrolled?5horner?8s?5method?5intrins@ DB 'unrolled hor'
	DB	'ner''s method intrinsics: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ODCOEDID@unrolled?5horner?8s?5method?5c?$CL?$CL?3?5?$AA@
CONST	SEGMENT
??_C@_0BP@ODCOEDID@unrolled?5horner?8s?5method?5c?$CL?$CL?3?5?$AA@ DB 'un'
	DB	'rolled horner''s method c++: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PCIHOKN@horner?8s?5method?5intrinsics?3?5?$AA@
CONST	SEGMENT
??_C@_0BN@PCIHOKN@horner?8s?5method?5intrinsics?3?5?$AA@ DB 'horner''s me'
	DB	'thod intrinsics: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GEKGDBFL@horner?8s?5method?5c?$CL?$CL?3?5?$AA@
CONST	SEGMENT
??_C@_0BG@GEKGDBFL@horner?8s?5method?5c?$CL?$CL?3?5?$AA@ DB 'horner''s me'
	DB	'thod c++: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DIAPNNHL@Accuracy?5Test?3?5?$AA@
CONST	SEGMENT
??_C@_0BA@DIAPNNHL@Accuracy?5Test?3?5?$AA@ DB 'Accuracy Test: ', 00H ; `string'
CONST	ENDS
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	_main
PUBLIC	?factoredP8SinSIMD@@YANN@Z			; factoredP8SinSIMD
PUBLIC	?factoredP8Sin@@YANN@Z				; factoredP8Sin
PUBLIC	?factoredP4SinSIMD@@YANN@Z			; factoredP4SinSIMD
PUBLIC	?factoredP4Sin@@YANN@Z				; factoredP4Sin
PUBLIC	?unrolledHornerSinP8SIMD@@YANN@Z		; unrolledHornerSinP8SIMD
PUBLIC	?unrolledHornerSinP8@@YANN@Z			; unrolledHornerSinP8
PUBLIC	?unrolledHornerSinP4SIMD@@YANN@Z		; unrolledHornerSinP4SIMD
PUBLIC	?unrolledHornerSinP4@@YANN@Z			; unrolledHornerSinP4
PUBLIC	?hornersMethodSIMD@@YANNPANI@Z			; hornersMethodSIMD
PUBLIC	?hornersMethod@@YANNPANH@Z			; hornersMethod
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	__real@0000000000000000
PUBLIC	__real@3e81a8bd333aee92
PUBLIC	__real@3ef1d38842f721be
PUBLIC	__real@3ef85dc4150da9f3
PUBLIC	__real@3f04a8fb9dce943e
PUBLIC	__real@3f2ccaf9ebd98c0b
PUBLIC	__real@3f324f5d7fa558bc
PUBLIC	__real@3f332321388fc9b8
PUBLIC	__real@3f54f3509055452e
PUBLIC	__real@3f5585088804c979
PUBLIC	__real@3f619829fbc8e728
PUBLIC	__real@3f77d138bd84f022
PUBLIC	__real@3f806b15f3ef65c3
PUBLIC	__real@3f88ae819b3a1229
PUBLIC	__real@3fa30d19d8575fff
PUBLIC	__real@3fa9d69d1d11cf8e
PUBLIC	__real@3fabe3733ad470ca
PUBLIC	__real@3fc4b2c46879b0f8
PUBLIC	__real@3fc55a0fd0f46665
PUBLIC	__real@3fcdeceea9321d76
PUBLIC	__real@3fdabb8f5f7d2415
PUBLIC	__real@3fef7177f65ab3d7
PUBLIC	__real@3feffff65b43d273
PUBLIC	__real@3ff00196e3891c7b
PUBLIC	__real@3ff4feeb64061ed0
PUBLIC	__real@400921cac083126f
PUBLIC	__real@400921fb65ed6164
PUBLIC	__real@400924b8343e6ef4
PUBLIC	__real@4013786cd7d05568
PUBLIC	__real@401794f1820e7d64
PUBLIC	__real@401b575f52239c9d
PUBLIC	__real@402a3cad4dae3fc8
PUBLIC	__real@4031554e2e2f05a3
PUBLIC	__real@4048569bf41890b3
PUBLIC	__real@4059000000000000
PUBLIC	__real@40dfffc000000000
PUBLIC	__real@412e848000000000
PUBLIC	__real@be81a8c2850e8406
PUBLIC	__real@bef1d38842f721be
PUBLIC	__real@bf55e6ffd208d315
PUBLIC	__real@bffb9dbcb6b90958
PUBLIC	__real@c00607e7cce90ccf
PUBLIC	__xmm@3f806b15f3ef65c33f2ccaf9ebd98c0b
PUBLIC	__xmm@3f88ae819b3a1229bf54f3509055452e
PUBLIC	__xmm@3fef7177f65ab3d73fabe3733ad470ca
PUBLIC	__xmm@3feffff65b43d2733f04a8fb9dce943e
PUBLIC	__xmm@3ff00196e3891c7bbf619829fbc8e728
PUBLIC	__xmm@3ff4feeb64061ed0bfdabb8f5f7d2415
PUBLIC	__xmm@400921fb65ed6164401794f1820e7d64
PUBLIC	__xmm@400924b8343e6ef44013786cd7d05568
PUBLIC	__xmm@401b575f52239c9dc02a3cad4dae3fc8
PUBLIC	__xmm@4031554e2e2f05a34048569bf41890b3
PUBLIC	__xmm@be81a8c2850e8406c00607e7cce90ccf
PUBLIC	__xmm@bf332321388fc9b83ef85dc4150da9f3
PUBLIC	__xmm@bf55e6ffd208d315bffb9dbcb6b90958
PUBLIC	__xmm@bfc4b2c46879b0f8bf77d138bd84f022
PUBLIC	__xmm@bfc55a0fd0f466653f324f5d7fa558bc
PUBLIC	__xmm@bfcdeceea9321d763fa30d19d8575fff
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__alldvrm:PROC
EXTRN	__allmul:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__ltod3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@bfcdeceea9321d763fa30d19d8575fff
CONST	SEGMENT
__xmm@bfcdeceea9321d763fa30d19d8575fff DB 0ffH, '_W', 0d8H, 019H, 0dH, 0a3H
	DB	'?v', 01dH, '2', 0a9H, 0eeH, 0ecH, 0cdH, 0bfH
CONST	ENDS
;	COMDAT __xmm@bfc55a0fd0f466653f324f5d7fa558bc
CONST	SEGMENT
__xmm@bfc55a0fd0f466653f324f5d7fa558bc DB 0bcH, 'X', 0a5H, 07fH, ']O2?ef', 0f4H
	DB	0d0H, 0fH, 'Z', 0c5H, 0bfH
CONST	ENDS
;	COMDAT __xmm@bfc4b2c46879b0f8bf77d138bd84f022
CONST	SEGMENT
__xmm@bfc4b2c46879b0f8bf77d138bd84f022 DB '"', 0f0H, 084H, 0bdH, '8', 0d1H
	DB	'w', 0bfH, 0f8H, 0b0H, 'yh', 0c4H, 0b2H, 0c4H, 0bfH
CONST	ENDS
;	COMDAT __xmm@bf55e6ffd208d315bffb9dbcb6b90958
CONST	SEGMENT
__xmm@bf55e6ffd208d315bffb9dbcb6b90958 DB 'X', 09H, 0b9H, 0b6H, 0bcH, 09dH
	DB	0fbH, 0bfH, 015H, 0d3H, 08H, 0d2H, 0ffH, 0e6H, 'U', 0bfH
CONST	ENDS
;	COMDAT __xmm@bf332321388fc9b83ef85dc4150da9f3
CONST	SEGMENT
__xmm@bf332321388fc9b83ef85dc4150da9f3 DB 0f3H, 0a9H, 0dH, 015H, 0c4H, ']'
	DB	0f8H, '>', 0b8H, 0c9H, 08fH, '8!#3', 0bfH
CONST	ENDS
;	COMDAT __xmm@be81a8c2850e8406c00607e7cce90ccf
CONST	SEGMENT
__xmm@be81a8c2850e8406c00607e7cce90ccf DB 0cfH, 0cH, 0e9H, 0ccH, 0e7H, 07H
	DB	06H, 0c0H, 06H, 084H, 0eH, 085H, 0c2H, 0a8H, 081H, 0beH
CONST	ENDS
;	COMDAT __xmm@4031554e2e2f05a34048569bf41890b3
CONST	SEGMENT
__xmm@4031554e2e2f05a34048569bf41890b3 DB 0b3H, 090H, 018H, 0f4H, 09bH, 'V'
	DB	'H@', 0a3H, 05H, '/.NU1@'
CONST	ENDS
;	COMDAT __xmm@401b575f52239c9dc02a3cad4dae3fc8
CONST	SEGMENT
__xmm@401b575f52239c9dc02a3cad4dae3fc8 DB 0c8H, '?', 0aeH, 'M', 0adH, '<*'
	DB	0c0H, 09dH, 09cH, '#R_W', 01bH, '@'
CONST	ENDS
;	COMDAT __xmm@400924b8343e6ef44013786cd7d05568
CONST	SEGMENT
__xmm@400924b8343e6ef44013786cd7d05568 DB 'hU', 0d0H, 0d7H, 'lx', 013H, '@'
	DB	0f4H, 'n>4', 0b8H, '$', 09H, '@'
CONST	ENDS
;	COMDAT __xmm@400921fb65ed6164401794f1820e7d64
CONST	SEGMENT
__xmm@400921fb65ed6164401794f1820e7d64 DB 'd}', 0eH, 082H, 0f1H, 094H, 017H
	DB	'@da', 0edH, 'e', 0fbH, '!', 09H, '@'
CONST	ENDS
;	COMDAT __xmm@3ff4feeb64061ed0bfdabb8f5f7d2415
CONST	SEGMENT
__xmm@3ff4feeb64061ed0bfdabb8f5f7d2415 DB 015H, '$}_', 08fH, 0bbH, 0daH, 0bfH
	DB	0d0H, 01eH, 06H, 'd', 0ebH, 0feH, 0f4H, '?'
CONST	ENDS
;	COMDAT __xmm@3ff00196e3891c7bbf619829fbc8e728
CONST	SEGMENT
__xmm@3ff00196e3891c7bbf619829fbc8e728 DB '(', 0e7H, 0c8H, 0fbH, ')', 098H
	DB	'a', 0bfH, '{', 01cH, 089H, 0e3H, 096H, 01H, 0f0H, '?'
CONST	ENDS
;	COMDAT __xmm@3feffff65b43d2733f04a8fb9dce943e
CONST	SEGMENT
__xmm@3feffff65b43d2733f04a8fb9dce943e DB '>', 094H, 0ceH, 09dH, 0fbH, 0a8H
	DB	04H, '?s', 0d2H, 'C[', 0f6H, 0ffH, 0efH, '?'
CONST	ENDS
;	COMDAT __xmm@3fef7177f65ab3d73fabe3733ad470ca
CONST	SEGMENT
__xmm@3fef7177f65ab3d73fabe3733ad470ca DB 0caH, 'p', 0d4H, ':s', 0e3H, 0abH
	DB	'?', 0d7H, 0b3H, 'Z', 0f6H, 'wq', 0efH, '?'
CONST	ENDS
;	COMDAT __xmm@3f88ae819b3a1229bf54f3509055452e
CONST	SEGMENT
__xmm@3f88ae819b3a1229bf54f3509055452e DB '.EU', 090H, 'P', 0f3H, 'T', 0bfH
	DB	')', 012H, ':', 09bH, 081H, 0aeH, 088H, '?'
CONST	ENDS
;	COMDAT __xmm@3f806b15f3ef65c33f2ccaf9ebd98c0b
CONST	SEGMENT
__xmm@3f806b15f3ef65c33f2ccaf9ebd98c0b DB 0bH, 08cH, 0d9H, 0ebH, 0f9H, 0caH
	DB	',?', 0c3H, 'e', 0efH, 0f3H, 015H, 'k', 080H, '?'
CONST	ENDS
;	COMDAT __real@c00607e7cce90ccf
CONST	SEGMENT
__real@c00607e7cce90ccf DQ 0c00607e7cce90ccfr	; -2.75386
CONST	ENDS
;	COMDAT __real@bffb9dbcb6b90958
CONST	SEGMENT
__real@bffb9dbcb6b90958 DQ 0bffb9dbcb6b90958r	; -1.72601
CONST	ENDS
;	COMDAT __real@bf55e6ffd208d315
CONST	SEGMENT
__real@bf55e6ffd208d315 DQ 0bf55e6ffd208d315r	; -0.00133681
CONST	ENDS
;	COMDAT __real@bef1d38842f721be
CONST	SEGMENT
__real@bef1d38842f721be DQ 0bef1d38842f721ber	; -1.70005e-05
CONST	ENDS
;	COMDAT __real@be81a8c2850e8406
CONST	SEGMENT
__real@be81a8c2850e8406 DQ 0be81a8c2850e8406r	; -1.31571e-07
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+06
CONST	ENDS
;	COMDAT __real@40dfffc000000000
CONST	SEGMENT
__real@40dfffc000000000 DQ 040dfffc000000000r	; 32767
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4048569bf41890b3
CONST	SEGMENT
__real@4048569bf41890b3 DQ 04048569bf41890b3r	; 48.6766
CONST	ENDS
;	COMDAT __real@4031554e2e2f05a3
CONST	SEGMENT
__real@4031554e2e2f05a3 DQ 04031554e2e2f05a3r	; 17.3332
CONST	ENDS
;	COMDAT __real@402a3cad4dae3fc8
CONST	SEGMENT
__real@402a3cad4dae3fc8 DQ 0402a3cad4dae3fc8r	; 13.1185
CONST	ENDS
;	COMDAT __real@401b575f52239c9d
CONST	SEGMENT
__real@401b575f52239c9d DQ 0401b575f52239c9dr	; 6.83532
CONST	ENDS
;	COMDAT __real@401794f1820e7d64
CONST	SEGMENT
__real@401794f1820e7d64 DQ 0401794f1820e7d64r	; 5.89545
CONST	ENDS
;	COMDAT __real@4013786cd7d05568
CONST	SEGMENT
__real@4013786cd7d05568 DQ 04013786cd7d05568r	; 4.8676
CONST	ENDS
;	COMDAT __real@400924b8343e6ef4
CONST	SEGMENT
__real@400924b8343e6ef4 DQ 0400924b8343e6ef4r	; 3.14293
CONST	ENDS
;	COMDAT __real@400921fb65ed6164
CONST	SEGMENT
__real@400921fb65ed6164 DQ 0400921fb65ed6164r	; 3.14159
CONST	ENDS
;	COMDAT __real@400921cac083126f
CONST	SEGMENT
__real@400921cac083126f DQ 0400921cac083126fr	; 3.1415
CONST	ENDS
;	COMDAT __real@3ff4feeb64061ed0
CONST	SEGMENT
__real@3ff4feeb64061ed0 DQ 03ff4feeb64061ed0r	; 1.31224
CONST	ENDS
;	COMDAT __real@3ff00196e3891c7b
CONST	SEGMENT
__real@3ff00196e3891c7b DQ 03ff00196e3891c7br	; 1.00039
CONST	ENDS
;	COMDAT __real@3feffff65b43d273
CONST	SEGMENT
__real@3feffff65b43d273 DQ 03feffff65b43d273r	; 0.999995
CONST	ENDS
;	COMDAT __real@3fef7177f65ab3d7
CONST	SEGMENT
__real@3fef7177f65ab3d7 DQ 03fef7177f65ab3d7r	; 0.982601
CONST	ENDS
;	COMDAT __real@3fdabb8f5f7d2415
CONST	SEGMENT
__real@3fdabb8f5f7d2415 DQ 03fdabb8f5f7d2415r	; 0.417698
CONST	ENDS
;	COMDAT __real@3fcdeceea9321d76
CONST	SEGMENT
__real@3fcdeceea9321d76 DQ 03fcdeceea9321d76r	; 0.233793
CONST	ENDS
;	COMDAT __real@3fc55a0fd0f46665
CONST	SEGMENT
__real@3fc55a0fd0f46665 DQ 03fc55a0fd0f46665r	; 0.166811
CONST	ENDS
;	COMDAT __real@3fc4b2c46879b0f8
CONST	SEGMENT
__real@3fc4b2c46879b0f8 DQ 03fc4b2c46879b0f8r	; 0.161706
CONST	ENDS
;	COMDAT __real@3fabe3733ad470ca
CONST	SEGMENT
__real@3fabe3733ad470ca DQ 03fabe3733ad470car	; 0.0544697
CONST	ENDS
;	COMDAT __real@3fa9d69d1d11cf8e
CONST	SEGMENT
__real@3fa9d69d1d11cf8e DQ 03fa9d69d1d11cf8er	; 0.0504655
CONST	ENDS
;	COMDAT __real@3fa30d19d8575fff
CONST	SEGMENT
__real@3fa30d19d8575fff DQ 03fa30d19d8575fffr	; 0.0372093
CONST	ENDS
;	COMDAT __real@3f88ae819b3a1229
CONST	SEGMENT
__real@3f88ae819b3a1229 DQ 03f88ae819b3a1229r	; 0.0120516
CONST	ENDS
;	COMDAT __real@3f806b15f3ef65c3
CONST	SEGMENT
__real@3f806b15f3ef65c3 DQ 03f806b15f3ef65c3r	; 0.00801675
CONST	ENDS
;	COMDAT __real@3f77d138bd84f022
CONST	SEGMENT
__real@3f77d138bd84f022 DQ 03f77d138bd84f022r	; 0.00581476
CONST	ENDS
;	COMDAT __real@3f619829fbc8e728
CONST	SEGMENT
__real@3f619829fbc8e728 DQ 03f619829fbc8e728r	; 0.00214775
CONST	ENDS
;	COMDAT __real@3f5585088804c979
CONST	SEGMENT
__real@3f5585088804c979 DQ 03f5585088804c979r	; 0.00131346
CONST	ENDS
;	COMDAT __real@3f54f3509055452e
CONST	SEGMENT
__real@3f54f3509055452e DQ 03f54f3509055452er	; 0.00127871
CONST	ENDS
;	COMDAT __real@3f332321388fc9b8
CONST	SEGMENT
__real@3f332321388fc9b8 DQ 03f332321388fc9b8r	; 0.000292011
CONST	ENDS
;	COMDAT __real@3f324f5d7fa558bc
CONST	SEGMENT
__real@3f324f5d7fa558bc DQ 03f324f5d7fa558bcr	; 0.000279389
CONST	ENDS
;	COMDAT __real@3f2ccaf9ebd98c0b
CONST	SEGMENT
__real@3f2ccaf9ebd98c0b DQ 03f2ccaf9ebd98c0br	; 0.000219672
CONST	ENDS
;	COMDAT __real@3f04a8fb9dce943e
CONST	SEGMENT
__real@3f04a8fb9dce943e DQ 03f04a8fb9dce943er	; 3.9406e-05
CONST	ENDS
;	COMDAT __real@3ef85dc4150da9f3
CONST	SEGMENT
__real@3ef85dc4150da9f3 DQ 03ef85dc4150da9f3r	; 2.32375e-05
CONST	ENDS
;	COMDAT __real@3ef1d38842f721be
CONST	SEGMENT
__real@3ef1d38842f721be DQ 03ef1d38842f721ber	; 1.70005e-05
CONST	ENDS
;	COMDAT __real@3e81a8bd333aee92
CONST	SEGMENT
__real@3e81a8bd333aee92 DQ 03e81a8bd333aee92r	; 1.31571e-07
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = ecx

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	ret	0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

	lea	edx, DWORD PTR [ecx+1]
	npad	5
$LL5@length:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL5@length
	sub	ecx, edx
	mov	eax, ecx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 594  : 		{	// test for metacharacter equality

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al

; 595  : 		return (_Left == _Right);
; 596  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

	or	eax, -1

; 607  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$dead$ = ecx

; 535  :             return _time64(_Time);

	push	0
	call	DWORD PTR __imp___time64
	add	esp, 4

; 536  :         }

	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$1$ = -12					; size = 4
tv212 = -8						; size = 4
__Freq$2$ = -4						; size = 4
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT
; ___$ReturnUdt$ = ecx

; 998  : 		{	// get current time

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR ___$ReturnUdt$1$[ebp], ecx

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	ebx, eax
	mov	edi, edx
	mov	DWORD PTR __Freq$2$[ebp], ebx

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	edi
	push	ebx
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv212[ebp], eax
	mov	ebx, edx
	call	__allmul
	push	edi
	push	DWORD PTR __Freq$2$[ebp]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	ebx
	push	DWORD PTR tv212[ebp]
	mov	esi, eax
	mov	edi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax

; 243  : 		: _MyDur(_Other)

	mov	eax, DWORD PTR ___$ReturnUdt$1$[ebp]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	edi, edx

; 243  : 		: _MyDur(_Other)

	mov	DWORD PTR [eax+4], edi

; 1005 : 		}

	pop	edi

; 243  : 		: _MyDur(_Other)

	mov	DWORD PTR [eax], esi

; 1005 : 		}

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?hornersMethod@@YANNPANH@Z
_TEXT	SEGMENT
?hornersMethod@@YANNPANH@Z PROC				; hornersMethod, COMDAT
; _c$ = ecx
; _length$ = edx
; _x$ = xmm2l

; 11   : double hornersMethod(double x, double* c, int length) {

	push	ecx
	push	esi

; 14   : 	for (int i = 0; i < length; i++) {

	xor	eax, eax
	movaps	xmm1, xmm2
	xorps	xmm0, xmm0
	push	edi
	mov	edi, ecx
	cmp	edx, 4
	jl	SHORT $LC12@hornersMet

; 12   : 
; 13   : 	double y = 0;

	lea	ecx, DWORD PTR [edx-4]
	shr	ecx, 2
	lea	esi, DWORD PTR [edi+16]
	inc	ecx
	lea	eax, DWORD PTR [ecx*4]

; 14   : 	for (int i = 0; i < length; i++) {

$LL13@hornersMet:

; 15   : 		y = c[i] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR [esi-16]
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR [esi-8]
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR [esi]
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR [esi+8]
	add	esi, 32					; 00000020H
	sub	ecx, 1
	jne	SHORT $LL13@hornersMet
$LC12@hornersMet:

; 14   : 	for (int i = 0; i < length; i++) {

	cmp	eax, edx
	jge	SHORT $LN11@hornersMet
$LC8@hornersMet:

; 15   : 		y = c[i] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR [edi+eax*8]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LC8@hornersMet
$LN11@hornersMet:

; 16   : 	}
; 17   : 
; 18   : 	return y;
; 19   : }

	pop	edi
	pop	esi
	pop	ecx
	ret	0
?hornersMethod@@YANNPANH@Z ENDP				; hornersMethod
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?hornersMethodSIMD@@YANNPANI@Z
_TEXT	SEGMENT
_w$ = -32						; size = 16
_length$1$ = -4						; size = 4
?hornersMethodSIMD@@YANNPANI@Z PROC			; hornersMethodSIMD, COMDAT
; _c$ = ecx
; _length$ = edx
; _x$ = xmm2l

; 21   : double hornersMethodSIMD(double x, double* c, unsigned int length) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 22   : 
; 23   : 	__m128d u, v, w;
; 24   : 
; 25   : 	u.m128d_f64[0] = x*x;
; 26   : 	u.m128d_f64[1] = x*x;						//u = | x^2 | x^2 |
; 27   : 
; 28   : 	w.m128d_f64[0] = c[0];

	movsd	xmm1, QWORD PTR [ecx]
	mov	eax, edx
	movsd	xmm0, QWORD PTR [ecx+8]
	movaps	xmm4, xmm2
	mov	DWORD PTR _length$1$[ebp], eax
	movaps	xmm3, xmm4
	unpcklpd xmm3, xmm3

; 29   : 	w.m128d_f64[1] = c[1];						//w = | c[1] | c[0] |
; 30   : 
; 31   : 	for (int i = 2; i < (length - 1); i += 2) {

	lea	edx, DWORD PTR [eax-1]
	movsd	QWORD PTR _w$[ebp], xmm1
	mov	eax, 2
	movsd	QWORD PTR _w$[ebp+8], xmm0
	movaps	xmm2, XMMWORD PTR _w$[ebp]
	mulpd	xmm3, xmm3
	cmp	edx, eax
	jbe	SHORT $LN3@hornersMet
	npad	1
$LL4@hornersMet:

; 32   : 		v.m128d_f64[0] = c[i];

	movsd	xmm1, QWORD PTR [ecx+eax*8]

; 33   : 		v.m128d_f64[1] = c[i + 1];				//v = | c[i+1] | c[i] |

	movsd	xmm0, QWORD PTR [ecx+eax*8+8]
	add	eax, 2

; 34   : 		w = _mm_mul_pd(u, w);					//w = | (x^2)*w[1] | (x^2)*w[0] |
; 35   : 		w = _mm_add_pd(v, w);					//w = | c[i+1] + x*w[1] | c[i] + x*w[0] |

	unpcklpd xmm1, xmm0
	mulpd	xmm2, xmm3
	addpd	xmm2, xmm1
	movaps	XMMWORD PTR _w$[ebp], xmm2
	cmp	eax, edx
	jb	SHORT $LL4@hornersMet

; 29   : 	w.m128d_f64[1] = c[1];						//w = | c[1] | c[0] |
; 30   : 
; 31   : 	for (int i = 2; i < (length - 1); i += 2) {

	movsd	xmm1, QWORD PTR _w$[ebp]
$LN3@hornersMet:

; 36   : 	}
; 37   : 
; 38   : 	if ((length % 2) == 0) {

	mov	eax, DWORD PTR _length$1$[ebp]
	test	al, 1
	jne	SHORT $LN5@hornersMet

; 39   : 		w.m128d_f64[0] *= x;					//w = | w[1] | x*w[0] |

	mulsd	xmm1, xmm4
	movsd	QWORD PTR _w$[ebp], xmm1

; 46   : 	}
; 47   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$[ebp]
	haddpd	xmm0, xmm0

; 48   : 
; 49   : 	return w.m128d_f64[0];
; 50   : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN5@hornersMet:

; 40   : 	}
; 41   : 	else {
; 42   : 		u.m128d_f64[0] = x*x;

	movaps	xmm0, xmm4
	mulsd	xmm0, xmm4

; 43   : 		u.m128d_f64[1] = x;						//u = | x | x^2 |
; 44   : 		w = _mm_mul_pd(u, w);					//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm0, xmm4
	mulpd	xmm2, xmm0

; 45   : 		w.m128d_f64[0] += c[length - 1];		//w = | w[1] | c[n] + w[0] |

	movsd	xmm0, QWORD PTR [ecx+eax*8-8]
	addsd	xmm0, xmm2
	movaps	XMMWORD PTR _w$[ebp], xmm2
	movsd	QWORD PTR _w$[ebp], xmm0

; 46   : 	}
; 47   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$[ebp]
	haddpd	xmm0, xmm0

; 48   : 
; 49   : 	return w.m128d_f64[0];
; 50   : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?hornersMethodSIMD@@YANNPANI@Z ENDP			; hornersMethodSIMD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?unrolledHornerSinP4@@YANN@Z
_TEXT	SEGMENT
?unrolledHornerSinP4@@YANN@Z PROC			; unrolledHornerSinP4, COMDAT
; _x$ = xmm0l

; 53   : 
; 54   : 	__declspec(align(16)) double c4[] = { 0.03720932737240900, -0.23379309903632944, 0.05446968167436379, 0.98260114780498042, 0.00131345589768425 };
; 55   : 	__declspec(align(16)) double y;
; 56   : 
; 57   : 	y = c4[0];
; 58   : 	y = c4[1] + x*y;

	movaps	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@3fa30d19d8575fff
	subsd	xmm1, QWORD PTR __real@3fcdeceea9321d76

; 59   : 	y = c4[2] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fabe3733ad470ca

; 60   : 	y = c4[3] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fef7177f65ab3d7

; 61   : 	y = c4[4] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3f5585088804c979

; 62   : 
; 63   : 	return y;
; 64   : }

	ret	0
?unrolledHornerSinP4@@YANN@Z ENDP			; unrolledHornerSinP4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?unrolledHornerSinP4SIMD@@YANN@Z
_TEXT	SEGMENT
_w$ = -16						; size = 16
?unrolledHornerSinP4SIMD@@YANN@Z PROC			; unrolledHornerSinP4SIMD, COMDAT
; _x$ = xmm0l

; 66   : double unrolledHornerSinP4SIMD(double x) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	movaps	xmm3, XMMWORD PTR __xmm@bfcdeceea9321d763fa30d19d8575fff
	movaps	xmm2, xmm0
	movaps	xmm1, xmm2

; 67   : 
; 68   : 	__declspec(align(16)) double c4[] = { 0.03720932737240900, -0.23379309903632944, 0.05446968167436379, 0.98260114780498042, 0.00131345589768425 };
; 69   : 
; 70   : 	__m128d u, v, w;
; 71   : 
; 72   : 	u.m128d_f64[0] = x*x;
; 73   : 	u.m128d_f64[1] = x*x;						//u = | x^2 | x^2 |
; 74   : 	v.m128d_f64[0] = c4[0];
; 75   : 	v.m128d_f64[1] = c4[1];						//v = | c[1] | c[0] |
; 76   : 	w = _mm_mul_pd(u, v);						//w = | (x^2)*c[1] | (x^2)*c[0] |
; 77   : 	v.m128d_f64[0] = c4[2];
; 78   : 	v.m128d_f64[1] = c4[3];						//v = | c[3] | c[2] |
; 79   : 	w = _mm_add_pd(w, v);						//w = | c[3] + (x^2)*c[1] | c[2] + (x^2)*c[0] |
; 80   : 	u.m128d_f64[0] = x*x;

	mulsd	xmm0, xmm2
	unpcklpd xmm1, xmm1
	mulpd	xmm1, xmm1

; 81   : 	u.m128d_f64[1] = x;							//u = | x | x^2 |
; 82   : 	w = _mm_mul_pd(u, w);						//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm0, xmm2
	mulpd	xmm3, xmm1
	addpd	xmm3, XMMWORD PTR __xmm@3fef7177f65ab3d73fabe3733ad470ca
	mulpd	xmm3, xmm0
	movaps	XMMWORD PTR _w$[ebp], xmm3

; 83   : 	w.m128d_f64[0] += c4[4];					//w = | w[1] | c[n] + w[0] |

	addsd	xmm3, QWORD PTR __real@3f5585088804c979
	movsd	QWORD PTR _w$[ebp], xmm3

; 84   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$[ebp]
	haddpd	xmm0, xmm0

; 85   : 
; 86   : 	return w.m128d_f64[0];
; 87   : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?unrolledHornerSinP4SIMD@@YANN@Z ENDP			; unrolledHornerSinP4SIMD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?unrolledHornerSinP8@@YANN@Z
_TEXT	SEGMENT
?unrolledHornerSinP8@@YANN@Z PROC			; unrolledHornerSinP8, COMDAT
; _x$ = xmm0l

; 91   : 
; 92   : 	__declspec(align(16)) double c8[] = { 2.32374889636375e-005, -2.92010889608420e-004, 2.19672210664518e-004, 8.01674986535062e-003, 2.79388739405372e-004, -1.66810967472702e-001, 3.94059931985509e-005, 9.99995401622597e-001, 1.31570823227546e-007 };
; 93   : 	__declspec(align(16)) double y;
; 94   : 
; 95   : 	y = c8[0];
; 96   : 	y = c8[1] + x*y;

	movaps	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@3ef85dc4150da9f3
	subsd	xmm1, QWORD PTR __real@3f332321388fc9b8

; 97   : 	y = c8[2] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3f2ccaf9ebd98c0b

; 98   : 	y = c8[3] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3f806b15f3ef65c3

; 99   : 	y = c8[4] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3f324f5d7fa558bc

; 100  : 	y = c8[5] + x*y;

	mulsd	xmm1, xmm0
	subsd	xmm1, QWORD PTR __real@3fc55a0fd0f46665

; 101  : 	y = c8[6] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3f04a8fb9dce943e

; 102  : 	y = c8[7] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3feffff65b43d273

; 103  : 	y = c8[8] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3e81a8bd333aee92

; 104  : 
; 105  : 	return y;
; 106  : }

	ret	0
?unrolledHornerSinP8@@YANN@Z ENDP			; unrolledHornerSinP8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?unrolledHornerSinP8SIMD@@YANN@Z
_TEXT	SEGMENT
_w$ = -16						; size = 16
?unrolledHornerSinP8SIMD@@YANN@Z PROC			; unrolledHornerSinP8SIMD, COMDAT
; _x$ = xmm0l

; 108  : double unrolledHornerSinP8SIMD(double x) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	movaps	xmm3, XMMWORD PTR __xmm@bf332321388fc9b83ef85dc4150da9f3
	movaps	xmm2, xmm0
	movaps	xmm1, xmm2

; 109  : 
; 110  : 	__declspec(align(16)) double c8[] = { 2.32374889636375e-005, -2.92010889608420e-004, 2.19672210664518e-004, 8.01674986535062e-003, 2.79388739405372e-004, -1.66810967472702e-001, 3.94059931985509e-005, 9.99995401622597e-001, 1.31570823227546e-007 };
; 111  : 	__m128d u, v, w;
; 112  : 
; 113  : 	u.m128d_f64[0] = x*x;
; 114  : 	u.m128d_f64[1] = x*x;						//u = | x^2 | x^2 |
; 115  : 	v.m128d_f64[0] = c8[0];
; 116  : 	v.m128d_f64[1] = c8[1];						//v = | c[1] | c[0] |
; 117  : 
; 118  : 	w = _mm_mul_pd(u, v);						//w = | (x^2)*c[1] | (x^2)*c[0] |
; 119  : 	v.m128d_f64[0] = c8[2];
; 120  : 	v.m128d_f64[1] = c8[3];						//v = | c[3] | c[2] |
; 121  : 	w = _mm_add_pd(w, v);						//w = | c[3] + (x^2)*c[1] | c[2] + (x^2)*c[0] |
; 122  : 
; 123  : 	w = _mm_mul_pd(u, w);						//w = | (x^2)*(c[3] + (x^2)*c[1]) | (x^2)*(c[2] + (x^2)*c[0]) |
; 124  : 	v.m128d_f64[0] = c8[4];
; 125  : 	v.m128d_f64[1] = c8[5];						//v = | c[5] | c[6] |
; 126  : 	w = _mm_add_pd(w, v);						//w = | c[5] + (x^2)*(c[3] + (x^2)*c[1]) | c[6] + (x^2)*(c[2] + (x^2)*c[0]) |
; 127  : 
; 128  : 	w = _mm_mul_pd(u, w);
; 129  : 	v.m128d_f64[0] = c8[6];
; 130  : 	v.m128d_f64[1] = c8[7];
; 131  : 	w = _mm_add_pd(w, v);						//...					
; 132  : 
; 133  : 	u.m128d_f64[0] = x*x;

	mulsd	xmm0, xmm2
	unpcklpd xmm1, xmm1
	mulpd	xmm1, xmm1

; 134  : 	u.m128d_f64[1] = x;							//u = | x | x^2 |
; 135  : 	w = _mm_mul_pd(u, w);						//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm0, xmm2
	mulpd	xmm3, xmm1
	addpd	xmm3, XMMWORD PTR __xmm@3f806b15f3ef65c33f2ccaf9ebd98c0b
	mulpd	xmm3, xmm1
	addpd	xmm3, XMMWORD PTR __xmm@bfc55a0fd0f466653f324f5d7fa558bc
	mulpd	xmm3, xmm1
	addpd	xmm3, XMMWORD PTR __xmm@3feffff65b43d2733f04a8fb9dce943e
	mulpd	xmm3, xmm0
	movaps	XMMWORD PTR _w$[ebp], xmm3

; 136  : 	w.m128d_f64[0] += c8[8];					//w = | w[1] | c[n] + w[0] |

	addsd	xmm3, QWORD PTR __real@3e81a8bd333aee92
	movsd	QWORD PTR _w$[ebp], xmm3

; 137  : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$[ebp]
	haddpd	xmm0, xmm0

; 138  : 
; 139  : 	return w.m128d_f64[0];
; 140  : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?unrolledHornerSinP8SIMD@@YANN@Z ENDP			; unrolledHornerSinP8SIMD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?factoredP4Sin@@YANN@Z
_TEXT	SEGMENT
?factoredP4Sin@@YANN@Z PROC				; factoredP4Sin, COMDAT
; _x$ = xmm0l

; 142  : double factoredP4Sin(double x) {

	movaps	xmm2, xmm0

; 143  : 
; 144  : 	__declspec(align(16)) double r4[] = { 4.86760270318095678, 3.14292946639567994, -1.72601004959195414, -0.00133681280580084 };
; 145  : 	__declspec(align(16)) double r4Magnitude = 0.03720932737240900;
; 146  : 
; 147  : 	return r4Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3]);

	subsd	xmm0, QWORD PTR __real@4013786cd7d05568
	movaps	xmm1, xmm2
	subsd	xmm1, QWORD PTR __real@400924b8343e6ef4
	mulsd	xmm0, QWORD PTR __real@3fa30d19d8575fff
	mulsd	xmm0, xmm1
	movaps	xmm1, xmm2
	subsd	xmm1, QWORD PTR __real@bffb9dbcb6b90958
	subsd	xmm2, QWORD PTR __real@bf55e6ffd208d315
	mulsd	xmm0, xmm1
	mulsd	xmm0, xmm2

; 148  : }

	ret	0
?factoredP4Sin@@YANN@Z ENDP				; factoredP4Sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?factoredP4SinSIMD@@YANN@Z
_TEXT	SEGMENT
?factoredP4SinSIMD@@YANN@Z PROC				; factoredP4SinSIMD, COMDAT
; _x$ = xmm0l

; 150  : double factoredP4SinSIMD(double x) {

	movaps	xmm1, xmm0

; 151  : 
; 152  : 	__declspec(align(16)) double r4[] = { 4.86760270318095678, 3.14292946639567994, -1.72601004959195414, -0.00133681280580084 };
; 153  : 	__declspec(align(16)) double r4Magnitude = 0.03720932737240900;
; 154  : 
; 155  : 	__m128d u, v, w;
; 156  : 
; 157  : 	u.m128d_f64[0] = r4[0];
; 158  : 	u.m128d_f64[1] = r4[1];				//u = | r4[1] | r4[0] |
; 159  : 	v.m128d_f64[0] = r4[2];
; 160  : 	v.m128d_f64[1] = r4[3];				//v = | r4[3] | r4[2] |
; 161  : 	w.m128d_f64[0] = x;
; 162  : 	w.m128d_f64[1] = x;					//w = | x | x |
; 163  : 
; 164  : 	u = _mm_sub_pd(w, u);				//u = | x - r4[1] | x - r4[0] |

	unpcklpd xmm1, xmm1
	movaps	xmm0, xmm1
	subpd	xmm0, XMMWORD PTR __xmm@400924b8343e6ef44013786cd7d05568

; 165  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	subpd	xmm1, XMMWORD PTR __xmm@bf55e6ffd208d315bffb9dbcb6b90958

; 166  : 	w = _mm_mul_pd(u, v);				//u = | (x - r4[1])(x - r4[3]) | (x - r4[0])(x - r4[2]) |

	mulpd	xmm1, xmm0

; 167  : 	w.m128d_f64[0] *= w.m128d_f64[1];	//w[0] = (x - r4[1])(x - r4[3])(x - r4[0])(x - r4[2])

	movaps	xmm0, xmm1
	unpckhpd xmm0, xmm1
	mulsd	xmm0, xmm1

; 168  : 	w.m128d_f64[0] *= r4Magnitude;		//w[0] = r4Magnitude*(x - r4[1])(x - r4[3])(x - r4[0])(x - r4[2])

	mulsd	xmm0, QWORD PTR __real@3fa30d19d8575fff

; 169  : 
; 170  : 	return w.m128d_f64[0];
; 171  : }

	ret	0
?factoredP4SinSIMD@@YANN@Z ENDP				; factoredP4SinSIMD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?factoredP8Sin@@YANN@Z
_TEXT	SEGMENT
?factoredP8Sin@@YANN@Z PROC				; factoredP8Sin, COMDAT
; _x$ = xmm0l

; 173  : double factoredP8Sin(double x) {

	movaps	xmm5, xmm0

; 174  : 
; 175  : 	__declspec(align(16)) double r4[] = { 5.895452530035389, 3.141592785174156, -2.753860092985270, -0.000000131571428 };
; 176  : 	__declspec(align(16)) double q1[] = { -13.1185097003180, 48.6766343231151 };
; 177  : 	__declspec(align(16)) double q2[] = { 6.83532455770833, 17.3332241883087 };
; 178  : 	__declspec(align(16)) double r8Magnitude = 2.32374889636375e-005;
; 179  : 
; 180  : 	return r8Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3])*(x*x + q1[0] * x + q1[1])*(x*x + q2[0] * x + q2[1]);

	subsd	xmm0, QWORD PTR __real@c00607e7cce90ccf
	movaps	xmm4, xmm5
	movaps	xmm1, xmm5
	subsd	xmm4, QWORD PTR __real@401794f1820e7d64
	subsd	xmm1, QWORD PTR __real@400921fb65ed6164
	movaps	xmm3, xmm5
	mulsd	xmm3, xmm5
	mulsd	xmm4, QWORD PTR __real@3ef85dc4150da9f3
	movaps	xmm2, xmm3
	mulsd	xmm4, xmm1
	movaps	xmm1, xmm5
	mulsd	xmm1, QWORD PTR __real@402a3cad4dae3fc8
	mulsd	xmm4, xmm0
	movaps	xmm0, xmm5
	subsd	xmm0, QWORD PTR __real@be81a8c2850e8406
	mulsd	xmm5, QWORD PTR __real@401b575f52239c9d
	subsd	xmm2, xmm1
	mulsd	xmm0, xmm4
	addsd	xmm2, QWORD PTR __real@4048569bf41890b3
	addsd	xmm5, xmm3
	mulsd	xmm0, xmm2
	addsd	xmm5, QWORD PTR __real@4031554e2e2f05a3
	mulsd	xmm0, xmm5

; 181  : }

	ret	0
?factoredP8Sin@@YANN@Z ENDP				; factoredP8Sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT ?factoredP8SinSIMD@@YANN@Z
_TEXT	SEGMENT
?factoredP8SinSIMD@@YANN@Z PROC				; factoredP8SinSIMD, COMDAT
; _x$ = xmm0l

; 183  : double factoredP8SinSIMD(double x) {

	movaps	xmm2, xmm0

; 184  : 
; 185  : 	__declspec(align(16)) double r4[] = { 5.895452530035389, 3.141592785174156, -2.753860092985270, -0.000000131571428 };
; 186  : 	__declspec(align(16)) double q1[] = { -13.1185097003180, 48.6766343231151 };
; 187  : 	__declspec(align(16)) double q2[] = { 6.83532455770833, 17.3332241883087 };
; 188  : 	__declspec(align(16)) double r8Magnitude = 2.32374889636375e-005;
; 189  : 
; 190  : 	__m128d s, t, u, v, w;
; 191  : 
; 192  : 	u.m128d_f64[0] = r4[0];
; 193  : 	u.m128d_f64[1] = r4[1];				//u = | r4[1] | r4[0] |
; 194  : 	v.m128d_f64[0] = r4[2];
; 195  : 	v.m128d_f64[1] = r4[3];				//v = | r4[3] | r4[2] |
; 196  : 	w.m128d_f64[0] = x;
; 197  : 	w.m128d_f64[1] = x;					//w = | x | x |
; 198  : 
; 199  : 	u = _mm_sub_pd(w, u);				//u = | x - r4[1] | x - r4[0] |
; 200  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	unpcklpd xmm2, xmm2
	movaps	xmm0, xmm2
	movaps	xmm1, xmm2
	subpd	xmm0, XMMWORD PTR __xmm@be81a8c2850e8406c00607e7cce90ccf
	subpd	xmm1, XMMWORD PTR __xmm@400921fb65ed6164401794f1820e7d64

; 201  : 	u = _mm_mul_pd(u, v);				//u = | (x - r4[1])(x - r4[3]) | (x - r4[0])(x - r4[2]) |

	mulpd	xmm1, xmm0
	movaps	xmm0, XMMWORD PTR __xmm@401b575f52239c9dc02a3cad4dae3fc8

; 202  : 
; 203  : 	s.m128d_f64[0] = q1[0];
; 204  : 	s.m128d_f64[1] = q2[0];				//s = | q2[0] | q1[0] |
; 205  : 	s = _mm_mul_pd(s, w);				//s = | x*q2[0] | x * q1[0] |

	mulpd	xmm0, xmm2

; 206  : 
; 207  : 	t.m128d_f64[0] = q1[1];
; 208  : 	t.m128d_f64[1] = q2[1];				//t = | q2[1] | q1[1] |
; 209  : 	w = _mm_mul_pd(w, w);				//w = | x^2 | x^2 |

	mulpd	xmm2, xmm2

; 210  : 	s = _mm_add_pd(t, s);				//s = | x*q2[0] + q2[1] | x * q1[0] + q1[1] |

	addpd	xmm0, XMMWORD PTR __xmm@4031554e2e2f05a34048569bf41890b3

; 211  : 	w = _mm_add_pd(w, s);				//w = | x^2 + x*q2[0] + q2[1] | x^2 + x * q1[0] + q1[1] |

	addpd	xmm2, xmm0

; 212  : 	w = _mm_mul_pd(w, u);				//w = | (x - r4[1])(x - r4[3])(x^2 + x*q2[0] + q2[1]) | (x - r4[0])(x - r4[2])(x^2 + x * q1[0] + q1[1]) |

	mulpd	xmm2, xmm1

; 213  : 	w.m128d_f64[0] *= w.m128d_f64[1];	//w[0] = w[1]*w[0]

	movaps	xmm0, xmm2
	unpckhpd xmm0, xmm2
	mulsd	xmm0, xmm2

; 214  : 	w.m128d_f64[0] *= r8Magnitude;		//w[0] = r4Magnitude*w[0]

	mulsd	xmm0, QWORD PTR __real@3ef85dc4150da9f3

; 215  : 
; 216  : 	return w.m128d_f64[0];
; 217  : }

	ret	0
?factoredP8SinSIMD@@YANN@Z ENDP				; factoredP8SinSIMD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp
;	COMDAT _main
_TEXT	SEGMENT
$T755 = -260						; size = 4
$T756 = -260						; size = 4
$T757 = -260						; size = 4
$T758 = -260						; size = 4
$T759 = -260						; size = 4
$T760 = -260						; size = 4
$T761 = -260						; size = 4
$T762 = -260						; size = 4
$T763 = -260						; size = 4
$T764 = -260						; size = 4
_t1$2$ = -260						; size = 4
__Freq$1$ = -260					; size = 4
$T765 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T766 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T767 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T768 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T769 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T770 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T771 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T772 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T773 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
$T774 = -256						; size = 4
__Freq$1$ = -256					; size = 4
__Freq$1$ = -256					; size = 4
_t1$1$ = -256						; size = 4
_y$1$ = -256						; size = 8
_x$5$ = -256						; size = 8
_x$3$ = -256						; size = 8
_w$4$ = -256						; size = 16
tv5584 = -256						; size = 16
_w$775 = -256						; size = 16
$T776 = -240						; size = 4
__Freq$1$ = -240					; size = 4
_y$1$ = -240						; size = 8
_w$4$ = -240						; size = 16
tv5363 = -240						; size = 4
tv5287 = -240						; size = 4
tv5246 = -240						; size = 4
tv5209 = -240						; size = 4
tv5172 = -240						; size = 4
tv5136 = -240						; size = 4
tv5101 = -240						; size = 4
tv5067 = -240						; size = 4
tv5032 = -240						; size = 4
tv4995 = -240						; size = 4
tv4960 = -240						; size = 4
tv4926 = -240						; size = 4
tv4891 = -240						; size = 4
tv4825 = -240						; size = 4
tv4790 = -240						; size = 4
tv4763 = -240						; size = 4
tv4728 = -240						; size = 4
tv4701 = -240						; size = 4
tv4666 = -240						; size = 4
tv4607 = -240						; size = 4
tv4545 = -240						; size = 4
_w$777 = -240						; size = 16
$T778 = -216						; size = 4
$T779 = -216						; size = 4
$T780 = -216						; size = 4
$T781 = -216						; size = 4
$T782 = -216						; size = 4
$T783 = -216						; size = 4
$T784 = -216						; size = 4
$T785 = -216						; size = 4
$T786 = -216						; size = 4
$T787 = -216						; size = 4
__Freq$2$ = -216					; size = 4
__Freq$2$ = -216					; size = 4
_y$1$ = -216						; size = 8
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
__Freq$2$ = -208					; size = 4
_y$1$ = -208						; size = 8
tv4572 = -208						; size = 4
_w$788 = -208						; size = 16
_w$2$ = -192						; size = 16
_w$6$ = -192						; size = 16
tv5591 = -192						; size = 16
_w$789 = -192						; size = 16
_w$790 = -192						; size = 16
_w$791 = -192						; size = 16
_w$792 = -192						; size = 16
_w$793 = -192						; size = 16
_w$794 = -192						; size = 16
_u$795 = -192						; size = 16
_test$1$ = -164						; size = 4
_c8$ = -160						; size = 72
_c6$ = -80						; size = 56
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 220  : {

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+260], eax
	movaps	xmm0, XMMWORD PTR __xmm@3f88ae819b3a1229bf54f3509055452e
	movaps	XMMWORD PTR _c6$[esp+260], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@bfc4b2c46879b0f8bf77d138bd84f022
	movaps	XMMWORD PTR _c6$[esp+276], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ff00196e3891c7bbf619829fbc8e728
	movaps	XMMWORD PTR _c6$[esp+292], xmm0

; 221  : 
; 222  : 	__declspec(align(16)) double c2[] = { -0.4176977570064662,   1.3122362048324483, -0.0504654977784461 };
; 223  : 	__declspec(align(16)) double c4[] = { 0.03720932737240900, -0.23379309903632944, 0.05446968167436379, 0.98260114780498042, 0.00131345589768425 };
; 224  : 	__declspec(align(16)) double c6[] = { -1.27871387060836e-003, 1.20515943047020e-002, -5.81476368125425e-003, -1.61705542577131e-001, -2.14775276097336e-003, 1.00038803940859e+000, -1.70004824988927e-005 };

	movsd	xmm0, QWORD PTR __real@bef1d38842f721be
	movsd	QWORD PTR _c6$[esp+308], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@bf332321388fc9b83ef85dc4150da9f3
	push	ebx
	movaps	XMMWORD PTR _c8$[esp+264], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f806b15f3ef65c33f2ccaf9ebd98c0b
	push	esi
	movaps	XMMWORD PTR _c8$[esp+284], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@bfc55a0fd0f466653f324f5d7fa558bc
	push	edi
	movaps	XMMWORD PTR _c8$[esp+304], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3feffff65b43d2733f04a8fb9dce943e

; 225  : 	__declspec(align(16)) double c8[] = { 2.32374889636375e-005, -2.92010889608420e-004, 2.19672210664518e-004, 8.01674986535062e-003, 2.79388739405372e-004, -1.66810967472702e-001, 3.94059931985509e-005, 9.99995401622597e-001, 1.31570823227546e-007 };
; 226  : 
; 227  : 	__declspec(align(16)) double x;
; 228  : 	int iterations = 1000000;
; 229  : 
; 230  : 	cout << endl << "Accuracy Test: " << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	XMMWORD PTR _c8$[esp+328], xmm0
	movsd	xmm0, QWORD PTR __real@3e81a8bd333aee92
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	movsd	QWORD PTR _c8$[esp+348], xmm0
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BA@DIAPNNHL@Accuracy?5Test?3?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 231  : 
; 232  : 	cout << endl << "horner's method c++: " << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BG@GEKGDBFL@horner?8s?5method?5c?$CL?$CL?3?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 233  : 	for (int n = 0; n < 100; n++) {

	xor	esi, esi
	xorps	xmm0, xmm0
	npad	13
$LL4@main:

; 234  : 		x = 3.1415*((double)n / 100.0);

	movd	xmm1, esi
	cvtdq2pd xmm1, xmm1
	divsd	xmm1, QWORD PTR __real@4059000000000000
	mulsd	xmm1, QWORD PTR __real@400921cac083126f

; 15   : 		y = c[i] + x*y;

	movaps	xmm2, xmm1
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm2
	subsd	xmm0, QWORD PTR __real@3fdabb8f5f7d2415
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3ff4feeb64061ed0
	mulsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@3fa9d69d1d11cf8e
	movsd	QWORD PTR _y$1$[esp+272], xmm0
	movaps	xmm0, xmm2
	addsd	xmm0, QWORD PTR __real@3fa30d19d8575fff
	mulsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@3fcdeceea9321d76
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3fabe3733ad470ca
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3fef7177f65ab3d7
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3f5585088804c979
	movsd	QWORD PTR _y$1$[esp+272], xmm0
	movaps	xmm0, xmm2
	addsd	xmm2, QWORD PTR __real@3ef85dc4150da9f3
	subsd	xmm0, QWORD PTR __real@3f54f3509055452e
	mulsd	xmm2, xmm1
	mulsd	xmm0, xmm1
	subsd	xmm2, QWORD PTR __real@3f332321388fc9b8
	addsd	xmm0, QWORD PTR __real@3f88ae819b3a1229
	mulsd	xmm2, xmm1
	mulsd	xmm0, xmm1
	addsd	xmm2, QWORD PTR __real@3f2ccaf9ebd98c0b
	subsd	xmm0, QWORD PTR __real@3f77d138bd84f022
	mulsd	xmm2, xmm1
	mulsd	xmm0, xmm1
	addsd	xmm2, QWORD PTR __real@3f806b15f3ef65c3
	subsd	xmm0, QWORD PTR __real@3fc4b2c46879b0f8
	mulsd	xmm2, xmm1
	mulsd	xmm0, xmm1
	addsd	xmm2, QWORD PTR __real@3f324f5d7fa558bc
	subsd	xmm0, QWORD PTR __real@3f619829fbc8e728
	mulsd	xmm2, xmm1
	mulsd	xmm0, xmm1
	subsd	xmm2, QWORD PTR __real@3fc55a0fd0f46665
	addsd	xmm0, QWORD PTR __real@3ff00196e3891c7b
	mulsd	xmm2, xmm1
	mulsd	xmm0, xmm1
	addsd	xmm2, QWORD PTR __real@3f04a8fb9dce943e
	subsd	xmm0, QWORD PTR __real@3ef1d38842f721be
	mulsd	xmm2, xmm1
	movsd	QWORD PTR _y$1$[esp+272], xmm0

; 235  : 		cout << sin(x) - hornersMethod(x, c8, 9)

	movaps	xmm0, xmm1

; 15   : 		y = c[i] + x*y;

	addsd	xmm2, QWORD PTR __real@3feffff65b43d273
	mulsd	xmm2, xmm1
	addsd	xmm2, QWORD PTR __real@3e81a8bd333aee92
	movsd	QWORD PTR _y$1$[esp+272], xmm2

; 235  : 		cout << sin(x) - hornersMethod(x, c8, 9)

	call	__libm_sse2_sin_precise
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	xmm2, xmm0
	subsd	xmm0, QWORD PTR _y$1$[esp+272]
	movaps	xmm1, xmm2
	subsd	xmm1, QWORD PTR _y$1$[esp+272]
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	sub	esp, 36					; 00000024H
	movsd	QWORD PTR [esp+28], xmm1
	movaps	xmm1, xmm2
	subsd	xmm1, QWORD PTR _y$1$[esp+312]
	subsd	xmm2, QWORD PTR _y$1$[esp+312]
	movsd	QWORD PTR [esp+16], xmm1
	movsd	QWORD PTR [esp+8], xmm0
	movsd	QWORD PTR [esp], xmm2
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	inc	esi
	xorps	xmm0, xmm0
	cmp	esi, 100				; 00000064H
	jl	$LL4@main

; 236  : 			<< ", " << sin(x) - hornersMethod(x, c6, 7)
; 237  : 			<< ", " << sin(x) - hornersMethod(x, c4, 5)
; 238  : 			<< ", " << sin(x) - hornersMethod(x, c2, 3)
; 239  : 			<< endl;
; 240  : 	}
; 241  : 
; 242  : 	cout << endl << "horner's method intrinsics: " << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BN@PCIHOKN@horner?8s?5method?5intrinsics?3?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 243  : 	for (int n = 0; n < 100; n++) {

	xor	esi, esi
	npad	8
$LL7@main:
	movd	xmm4, esi

; 31   : 	for (int i = 2; i < (length - 1); i += 2) {

	mov	eax, 2

; 244  : 		x = 3.1415*((double)n / 100.0);

	cvtdq2pd xmm4, xmm4
	movaps	xmm1, XMMWORD PTR __xmm@3ff4feeb64061ed0bfdabb8f5f7d2415
	divsd	xmm4, QWORD PTR __real@4059000000000000
	movaps	xmm2, XMMWORD PTR __xmm@3f88ae819b3a1229bf54f3509055452e
	mulsd	xmm4, QWORD PTR __real@400921cac083126f
	movaps	xmm3, xmm4

; 42   : 		u.m128d_f64[0] = x*x;

	movaps	xmm5, xmm4
	unpcklpd xmm3, xmm3

; 16   : 	}
; 17   : 
; 18   : 	return y;
; 19   : }
; 20   : 
; 21   : double hornersMethodSIMD(double x, double* c, unsigned int length) {
; 22   : 
; 23   : 	__m128d u, v, w;
; 24   : 
; 25   : 	u.m128d_f64[0] = x*x;

	movaps	xmm0, xmm3

; 36   : 	}
; 37   : 
; 38   : 	if ((length % 2) == 0) {
; 39   : 		w.m128d_f64[0] *= x;					//w = | w[1] | x*w[0] |
; 40   : 	}
; 41   : 	else {
; 42   : 		u.m128d_f64[0] = x*x;

	mulsd	xmm5, xmm4
	mulpd	xmm0, xmm3

; 25   : 	u.m128d_f64[0] = x*x;

	movaps	xmm6, xmm3
	movaps	XMMWORD PTR _u$795[esp+272], xmm0

; 43   : 		u.m128d_f64[1] = x;						//u = | x | x^2 |
; 44   : 		w = _mm_mul_pd(u, w);					//w = | x*w[1] | (x^2)*w[0] |

	movaps	xmm0, xmm5
	unpcklpd xmm0, xmm4
	mulpd	xmm1, xmm0
	mulpd	xmm6, xmm3
	movaps	XMMWORD PTR _w$794[esp+272], xmm1

; 45   : 		w.m128d_f64[0] += c[length - 1];		//w = | w[1] | c[n] + w[0] |

	subsd	xmm1, QWORD PTR __real@3fa9d69d1d11cf8e
	movsd	QWORD PTR _w$794[esp+272], xmm1

; 46   : 	}
; 47   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$794[esp+272]
	movaps	xmm1, XMMWORD PTR __xmm@bfcdeceea9321d763fa30d19d8575fff
	haddpd	xmm0, xmm0
	movaps	XMMWORD PTR _w$794[esp+272], xmm0

; 25   : 	u.m128d_f64[0] = x*x;

	movaps	xmm0, xmm3
	mulpd	xmm0, xmm3

; 34   : 		w = _mm_mul_pd(u, w);					//w = | (x^2)*w[1] | (x^2)*w[0] |

	mulpd	xmm1, xmm0

; 43   : 		u.m128d_f64[1] = x;						//u = | x | x^2 |
; 44   : 		w = _mm_mul_pd(u, w);					//w = | x*w[1] | (x^2)*w[0] |

	movaps	xmm0, xmm5
	addpd	xmm1, XMMWORD PTR __xmm@3fef7177f65ab3d73fabe3733ad470ca
	unpcklpd xmm0, xmm4
	mulpd	xmm1, xmm0
	movaps	XMMWORD PTR _w$775[esp+272], xmm1

; 45   : 		w.m128d_f64[0] += c[length - 1];		//w = | w[1] | c[n] + w[0] |

	addsd	xmm1, QWORD PTR __real@3f5585088804c979
	movsd	QWORD PTR _w$775[esp+272], xmm1

; 46   : 	}
; 47   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$775[esp+272]
	haddpd	xmm0, xmm0
	movaps	XMMWORD PTR _w$775[esp+272], xmm0
	npad	2
$LL94@main:

; 32   : 		v.m128d_f64[0] = c[i];

	movsd	xmm1, QWORD PTR _c6$[esp+eax*8+272]

; 33   : 		v.m128d_f64[1] = c[i + 1];				//v = | c[i+1] | c[i] |

	movsd	xmm0, QWORD PTR _c6$[esp+eax*8+280]
	add	eax, 2

; 35   : 		w = _mm_add_pd(v, w);					//w = | c[i+1] + x*w[1] | c[i] + x*w[0] |

	unpcklpd xmm1, xmm0
	mulpd	xmm2, xmm6
	addpd	xmm2, xmm1
	cmp	eax, 6
	jb	SHORT $LL94@main

; 43   : 		u.m128d_f64[1] = x;						//u = | x | x^2 |
; 44   : 		w = _mm_mul_pd(u, w);					//w = | x*w[1] | (x^2)*w[0] |

	movaps	xmm0, xmm5

; 31   : 	for (int i = 2; i < (length - 1); i += 2) {

	mov	eax, 2

; 44   : 		w = _mm_mul_pd(u, w);					//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm0, xmm4
	mulpd	xmm2, xmm0
	mulpd	xmm3, xmm3
	movaps	XMMWORD PTR _w$788[esp+272], xmm2

; 45   : 		w.m128d_f64[0] += c[length - 1];		//w = | w[1] | c[n] + w[0] |

	subsd	xmm2, QWORD PTR __real@3ef1d38842f721be
	movsd	QWORD PTR _w$788[esp+272], xmm2

; 46   : 	}
; 47   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$788[esp+272]
	movaps	xmm2, XMMWORD PTR __xmm@bf332321388fc9b83ef85dc4150da9f3
	haddpd	xmm0, xmm0
	movaps	XMMWORD PTR _w$788[esp+272], xmm0
	npad	14
$LL101@main:

; 32   : 		v.m128d_f64[0] = c[i];

	movsd	xmm1, QWORD PTR _c8$[esp+eax*8+272]

; 33   : 		v.m128d_f64[1] = c[i + 1];				//v = | c[i+1] | c[i] |

	movsd	xmm0, QWORD PTR _c8$[esp+eax*8+280]
	add	eax, 2

; 35   : 		w = _mm_add_pd(v, w);					//w = | c[i+1] + x*w[1] | c[i] + x*w[0] |

	unpcklpd xmm1, xmm0
	mulpd	xmm2, xmm3
	addpd	xmm2, xmm1
	cmp	eax, 8
	jb	SHORT $LL101@main

; 43   : 		u.m128d_f64[1] = x;						//u = | x | x^2 |
; 44   : 		w = _mm_mul_pd(u, w);					//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm5, xmm4
	mulpd	xmm2, xmm5
	movaps	XMMWORD PTR _w$777[esp+272], xmm2

; 45   : 		w.m128d_f64[0] += c[length - 1];		//w = | w[1] | c[n] + w[0] |

	addsd	xmm2, QWORD PTR __real@3e81a8bd333aee92
	movsd	QWORD PTR _w$777[esp+272], xmm2

; 46   : 	}
; 47   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$777[esp+272]
	haddpd	xmm0, xmm0
	movaps	XMMWORD PTR _w$4$[esp+272], xmm0

; 245  : 		cout << sin(x) - hornersMethodSIMD(x, c8, 9)

	movaps	xmm0, xmm4
	call	__libm_sse2_sin_precise
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	xmm2, xmm0
	subsd	xmm0, QWORD PTR _w$788[esp+272]
	movaps	xmm1, xmm2
	subsd	xmm1, QWORD PTR _w$794[esp+272]
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	sub	esp, 36					; 00000024H
	movsd	QWORD PTR [esp+28], xmm1
	movaps	xmm1, xmm2
	subsd	xmm1, QWORD PTR _w$775[esp+312]
	subsd	xmm2, QWORD PTR _w$4$[esp+312]
	movsd	QWORD PTR [esp+16], xmm1
	movsd	QWORD PTR [esp+8], xmm0
	movsd	QWORD PTR [esp], xmm2
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	inc	esi
	cmp	esi, 100				; 00000064H
	jl	$LL7@main

; 246  : 			<< ", " << sin(x) - hornersMethodSIMD(x, c6, 7)
; 247  : 			<< ", " << sin(x) - hornersMethodSIMD(x, c4, 5)
; 248  : 			<< ", " << sin(x) - hornersMethodSIMD(x, c2, 3)
; 249  : 			<< endl;
; 250  : 	}
; 251  : 
; 252  : 	cout << endl << "unrolled horner's method c++: " << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BP@ODCOEDID@unrolled?5horner?8s?5method?5c?$CL?$CL?3?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 253  : 	for (int n = 0; n < 100; n++) {

	xor	esi, esi
	npad	2
$LL10@main:

; 254  : 		x = 3.1415*((double)n / 100.0);

	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4059000000000000
	mulsd	xmm0, QWORD PTR __real@400921cac083126f
	movsd	QWORD PTR _x$3$[esp+272], xmm0

; 255  : 		cout << sin(x) - unrolledHornerSinP8(x)

	call	__libm_sse2_sin_precise

; 58   : 	y = c4[1] + x*y;

	movsd	xmm3, QWORD PTR _x$3$[esp+272]

; 255  : 		cout << sin(x) - unrolledHornerSinP8(x)

	movaps	xmm2, xmm0

; 58   : 	y = c4[1] + x*y;

	movaps	xmm1, xmm3

; 255  : 		cout << sin(x) - unrolledHornerSinP8(x)

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A

; 58   : 	y = c4[1] + x*y;

	mulsd	xmm1, QWORD PTR __real@3fa30d19d8575fff

; 255  : 		cout << sin(x) - unrolledHornerSinP8(x)

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	sub	esp, 20					; 00000014H

; 58   : 	y = c4[1] + x*y;

	subsd	xmm1, QWORD PTR __real@3fcdeceea9321d76

; 59   : 	y = c4[2] + x*y;

	mulsd	xmm1, xmm3
	addsd	xmm1, QWORD PTR __real@3fabe3733ad470ca

; 60   : 	y = c4[3] + x*y;

	mulsd	xmm1, xmm3
	addsd	xmm1, QWORD PTR __real@3fef7177f65ab3d7

; 61   : 	y = c4[4] + x*y;

	mulsd	xmm1, xmm3
	addsd	xmm1, QWORD PTR __real@3f5585088804c979

; 255  : 		cout << sin(x) - unrolledHornerSinP8(x)

	subsd	xmm0, xmm1
	movsd	QWORD PTR [esp+12], xmm0

; 96   : 	y = c8[1] + x*y;

	movaps	xmm0, xmm3
	mulsd	xmm0, QWORD PTR __real@3ef85dc4150da9f3
	subsd	xmm0, QWORD PTR __real@3f332321388fc9b8

; 97   : 	y = c8[2] + x*y;

	mulsd	xmm0, xmm3
	addsd	xmm0, QWORD PTR __real@3f2ccaf9ebd98c0b

; 98   : 	y = c8[3] + x*y;

	mulsd	xmm0, xmm3
	addsd	xmm0, QWORD PTR __real@3f806b15f3ef65c3

; 99   : 	y = c8[4] + x*y;

	mulsd	xmm0, xmm3
	addsd	xmm0, QWORD PTR __real@3f324f5d7fa558bc

; 100  : 	y = c8[5] + x*y;

	mulsd	xmm0, xmm3
	subsd	xmm0, QWORD PTR __real@3fc55a0fd0f46665

; 101  : 	y = c8[6] + x*y;

	mulsd	xmm0, xmm3
	addsd	xmm0, QWORD PTR __real@3f04a8fb9dce943e

; 102  : 	y = c8[7] + x*y;

	mulsd	xmm0, xmm3
	addsd	xmm0, QWORD PTR __real@3feffff65b43d273

; 103  : 	y = c8[8] + x*y;

	mulsd	xmm0, xmm3
	addsd	xmm0, QWORD PTR __real@3e81a8bd333aee92

; 255  : 		cout << sin(x) - unrolledHornerSinP8(x)

	subsd	xmm2, xmm0
	movsd	QWORD PTR [esp], xmm2
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	inc	esi
	cmp	esi, 100				; 00000064H
	jl	$LL10@main

; 256  : 			<< ", " << sin(x) - unrolledHornerSinP4(x)
; 257  : 			<< endl;
; 258  : 	}
; 259  : 
; 260  : 	cout << endl << "unrolled horner's method intrinsics: " << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0CG@CAPGOKJE@unrolled?5horner?8s?5method?5intrins@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 261  : 	for (int n = 0; n < 100; n++) {

	xor	esi, esi
	npad	6
$LL13@main:

; 262  : 		x = 3.1415*((double)n / 100.0);

	movd	xmm4, esi
	cvtdq2pd xmm4, xmm4
	movaps	xmm1, XMMWORD PTR __xmm@bfcdeceea9321d763fa30d19d8575fff
	divsd	xmm4, QWORD PTR __real@4059000000000000
	mulsd	xmm4, QWORD PTR __real@400921cac083126f
	movaps	xmm3, xmm4

; 80   : 	u.m128d_f64[0] = x*x;

	movaps	xmm2, xmm4
	unpcklpd xmm3, xmm3

; 62   : 
; 63   : 	return y;
; 64   : }
; 65   : 
; 66   : double unrolledHornerSinP4SIMD(double x) {
; 67   : 
; 68   : 	__declspec(align(16)) double c4[] = { 0.03720932737240900, -0.23379309903632944, 0.05446968167436379, 0.98260114780498042, 0.00131345589768425 };
; 69   : 
; 70   : 	__m128d u, v, w;
; 71   : 
; 72   : 	u.m128d_f64[0] = x*x;

	movaps	xmm0, xmm3

; 80   : 	u.m128d_f64[0] = x*x;

	mulsd	xmm2, xmm4
	mulpd	xmm0, xmm3
	mulpd	xmm3, xmm3

; 76   : 	w = _mm_mul_pd(u, v);						//w = | (x^2)*c[1] | (x^2)*c[0] |

	mulpd	xmm1, xmm0

; 81   : 	u.m128d_f64[1] = x;							//u = | x | x^2 |
; 82   : 	w = _mm_mul_pd(u, w);						//w = | x*w[1] | (x^2)*w[0] |

	movaps	xmm0, xmm2

; 135  : 	w = _mm_mul_pd(u, w);						//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm2, xmm4

; 79   : 	w = _mm_add_pd(w, v);						//w = | c[3] + (x^2)*c[1] | c[2] + (x^2)*c[0] |

	addpd	xmm1, XMMWORD PTR __xmm@3fef7177f65ab3d73fabe3733ad470ca

; 81   : 	u.m128d_f64[1] = x;							//u = | x | x^2 |
; 82   : 	w = _mm_mul_pd(u, w);						//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm0, xmm4
	mulpd	xmm1, xmm0
	movaps	XMMWORD PTR _w$793[esp+272], xmm1

; 83   : 	w.m128d_f64[0] += c4[4];					//w = | w[1] | c[n] + w[0] |

	addsd	xmm1, QWORD PTR __real@3f5585088804c979
	movsd	QWORD PTR _w$793[esp+272], xmm1
	movaps	xmm1, XMMWORD PTR __xmm@bf332321388fc9b83ef85dc4150da9f3

; 118  : 	w = _mm_mul_pd(u, v);						//w = | (x^2)*c[1] | (x^2)*c[0] |

	mulpd	xmm1, xmm3

; 84   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$793[esp+272]

; 121  : 	w = _mm_add_pd(w, v);						//w = | c[3] + (x^2)*c[1] | c[2] + (x^2)*c[0] |

	addpd	xmm1, XMMWORD PTR __xmm@3f806b15f3ef65c33f2ccaf9ebd98c0b

; 84   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	haddpd	xmm0, xmm0

; 123  : 	w = _mm_mul_pd(u, w);						//w = | (x^2)*(c[3] + (x^2)*c[1]) | (x^2)*(c[2] + (x^2)*c[0]) |

	mulpd	xmm1, xmm3

; 84   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	XMMWORD PTR _w$4$[esp+272], xmm0

; 126  : 	w = _mm_add_pd(w, v);						//w = | c[5] + (x^2)*(c[3] + (x^2)*c[1]) | c[6] + (x^2)*(c[2] + (x^2)*c[0]) |

	addpd	xmm1, XMMWORD PTR __xmm@bfc55a0fd0f466653f324f5d7fa558bc

; 127  : 
; 128  : 	w = _mm_mul_pd(u, w);

	mulpd	xmm1, xmm3

; 129  : 	v.m128d_f64[0] = c8[6];
; 130  : 	v.m128d_f64[1] = c8[7];
; 131  : 	w = _mm_add_pd(w, v);						//...					

	addpd	xmm1, XMMWORD PTR __xmm@3feffff65b43d2733f04a8fb9dce943e

; 134  : 	u.m128d_f64[1] = x;							//u = | x | x^2 |
; 135  : 	w = _mm_mul_pd(u, w);						//w = | x*w[1] | (x^2)*w[0] |

	mulpd	xmm1, xmm2
	movaps	XMMWORD PTR _w$792[esp+272], xmm1

; 136  : 	w.m128d_f64[0] += c8[8];					//w = | w[1] | c[n] + w[0] |

	addsd	xmm1, QWORD PTR __real@3e81a8bd333aee92
	movsd	QWORD PTR _w$792[esp+272], xmm1

; 137  : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$792[esp+272]
	haddpd	xmm0, xmm0
	movaps	XMMWORD PTR _w$6$[esp+272], xmm0

; 263  : 		cout << sin(x) - unrolledHornerSinP8SIMD(x)

	movaps	xmm0, xmm4
	call	__libm_sse2_sin_precise
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	xmm1, xmm0
	subsd	xmm1, QWORD PTR _w$4$[esp+272]
	subsd	xmm0, QWORD PTR _w$6$[esp+272]
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	sub	esp, 20					; 00000014H
	movsd	QWORD PTR [esp+12], xmm1
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	inc	esi
	cmp	esi, 100				; 00000064H
	jl	$LL13@main

; 264  : 			<< ", " << sin(x) - unrolledHornerSinP4SIMD(x)
; 265  : 			<< endl;
; 266  : 	}
; 267  : 
; 268  : 	cout << endl << "factored c++: " << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0P@ICANGEBK@factored?5c?$CL?$CL?3?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 269  : 	for (int n = 0; n < 100; n++) {

	xor	esi, esi
	npad	13
$LL16@main:

; 270  : 		x = 3.1415*((double)n / 100.0);

	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4059000000000000
	mulsd	xmm0, QWORD PTR __real@400921cac083126f
	movsd	QWORD PTR _x$5$[esp+272], xmm0

; 271  : 		cout << sin(x) - factoredP8Sin(x)

	call	__libm_sse2_sin_precise

; 180  : 	return r8Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3])*(x*x + q1[0] * x + q1[1])*(x*x + q2[0] * x + q2[1]);

	movsd	xmm5, QWORD PTR _x$5$[esp+272]

; 271  : 		cout << sin(x) - factoredP8Sin(x)

	movaps	xmm4, xmm0

; 147  : 	return r4Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3]);

	movaps	xmm2, xmm5

; 271  : 		cout << sin(x) - factoredP8Sin(x)

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A

; 147  : 	return r4Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3]);

	subsd	xmm2, QWORD PTR __real@4013786cd7d05568
	movaps	xmm1, xmm5
	movaps	xmm0, xmm5
	subsd	xmm0, QWORD PTR __real@bffb9dbcb6b90958
	subsd	xmm1, QWORD PTR __real@400924b8343e6ef4

; 271  : 		cout << sin(x) - factoredP8Sin(x)

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >

; 147  : 	return r4Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3]);

	mulsd	xmm2, QWORD PTR __real@3fa30d19d8575fff

; 271  : 		cout << sin(x) - factoredP8Sin(x)

	sub	esp, 20					; 00000014H

; 180  : 	return r8Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3])*(x*x + q1[0] * x + q1[1])*(x*x + q2[0] * x + q2[1]);

	movaps	xmm3, xmm5
	mulsd	xmm3, xmm5

; 147  : 	return r4Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3]);

	mulsd	xmm2, xmm1

; 180  : 	return r8Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3])*(x*x + q1[0] * x + q1[1])*(x*x + q2[0] * x + q2[1]);

	movaps	xmm1, xmm3

; 147  : 	return r4Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3]);

	mulsd	xmm2, xmm0
	movaps	xmm0, xmm5
	subsd	xmm0, QWORD PTR __real@bf55e6ffd208d315
	mulsd	xmm2, xmm0

; 271  : 		cout << sin(x) - factoredP8Sin(x)

	movaps	xmm0, xmm4
	subsd	xmm0, xmm2

; 180  : 	return r8Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3])*(x*x + q1[0] * x + q1[1])*(x*x + q2[0] * x + q2[1]);

	movaps	xmm2, xmm5
	subsd	xmm2, QWORD PTR __real@401794f1820e7d64

; 271  : 		cout << sin(x) - factoredP8Sin(x)

	movsd	QWORD PTR [esp+12], xmm0

; 180  : 	return r8Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3])*(x*x + q1[0] * x + q1[1])*(x*x + q2[0] * x + q2[1]);

	movaps	xmm0, xmm5
	subsd	xmm0, QWORD PTR __real@400921fb65ed6164
	mulsd	xmm2, QWORD PTR __real@3ef85dc4150da9f3
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm5
	subsd	xmm0, QWORD PTR __real@c00607e7cce90ccf
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm5
	subsd	xmm0, QWORD PTR __real@be81a8c2850e8406
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm5
	mulsd	xmm0, QWORD PTR __real@402a3cad4dae3fc8
	mulsd	xmm5, QWORD PTR __real@401b575f52239c9d
	subsd	xmm1, xmm0
	addsd	xmm5, xmm3
	addsd	xmm1, QWORD PTR __real@4048569bf41890b3
	addsd	xmm5, QWORD PTR __real@4031554e2e2f05a3
	mulsd	xmm2, xmm1
	mulsd	xmm2, xmm5

; 271  : 		cout << sin(x) - factoredP8Sin(x)

	subsd	xmm4, xmm2
	movsd	QWORD PTR [esp], xmm4
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	inc	esi
	cmp	esi, 100				; 00000064H
	jl	$LL16@main

; 272  : 			<< ", " << sin(x) - factoredP4Sin(x)
; 273  : 			<< endl;
; 274  : 	}
; 275  : 
; 276  : 	cout << endl << "factored with intrinsics: " << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BL@FPFKILKD@factored?5with?5intrinsics?3?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 277  : 	for (int n = 0; n < 100; n++) {

	xor	esi, esi
	npad	4
$LL19@main:

; 278  : 		x = 3.1415*((double)n / 100.0);

	movd	xmm4, esi
	cvtdq2pd xmm4, xmm4

; 164  : 	u = _mm_sub_pd(w, u);				//u = | x - r4[1] | x - r4[0] |

	movsd	xmm3, QWORD PTR __real@400924b8343e6ef4

; 278  : 		x = 3.1415*((double)n / 100.0);

	divsd	xmm4, QWORD PTR __real@4059000000000000

; 164  : 	u = _mm_sub_pd(w, u);				//u = | x - r4[1] | x - r4[0] |

	movsd	xmm0, QWORD PTR __real@4013786cd7d05568

; 278  : 		x = 3.1415*((double)n / 100.0);

	mulsd	xmm4, QWORD PTR __real@400921cac083126f

; 164  : 	u = _mm_sub_pd(w, u);				//u = | x - r4[1] | x - r4[0] |

	unpcklpd xmm0, xmm3

; 165  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	movsd	xmm3, QWORD PTR __real@bf55e6ffd208d315

; 199  : 	u = _mm_sub_pd(w, u);				//u = | x - r4[1] | x - r4[0] |

	movsd	xmm5, QWORD PTR __real@400921fb65ed6164

; 164  : 	u = _mm_sub_pd(w, u);				//u = | x - r4[1] | x - r4[0] |

	movaps	xmm2, xmm4
	unpcklpd xmm2, xmm4
	movaps	xmm1, xmm2
	subpd	xmm1, xmm0

; 165  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	movsd	xmm0, QWORD PTR __real@bffb9dbcb6b90958
	unpcklpd xmm0, xmm3

; 200  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	movaps	xmm3, xmm4

; 165  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	subpd	xmm2, xmm0

; 200  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	unpcklpd xmm3, xmm4

; 166  : 	w = _mm_mul_pd(u, v);				//u = | (x - r4[1])(x - r4[3]) | (x - r4[0])(x - r4[2]) |

	mulpd	xmm2, xmm1

; 200  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	movaps	xmm1, xmm3

; 167  : 	w.m128d_f64[0] *= w.m128d_f64[1];	//w[0] = (x - r4[1])(x - r4[3])(x - r4[0])(x - r4[2])

	movaps	xmm0, xmm2
	unpckhpd xmm0, xmm2
	mulsd	xmm0, xmm2

; 200  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	movsd	xmm2, QWORD PTR __real@be81a8c2850e8406

; 168  : 	w.m128d_f64[0] *= r4Magnitude;		//w[0] = r4Magnitude*(x - r4[1])(x - r4[3])(x - r4[0])(x - r4[2])

	mulsd	xmm0, QWORD PTR __real@3fa30d19d8575fff
	movaps	XMMWORD PTR tv5591[esp+272], xmm0

; 200  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	movsd	xmm0, QWORD PTR __real@c00607e7cce90ccf
	unpcklpd xmm0, xmm2
	movaps	xmm2, xmm3
	subpd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@401794f1820e7d64
	unpcklpd xmm0, xmm5
	subpd	xmm2, xmm0
	movaps	xmm0, XMMWORD PTR __xmm@401b575f52239c9dc02a3cad4dae3fc8

; 201  : 	u = _mm_mul_pd(u, v);				//u = | (x - r4[1])(x - r4[3]) | (x - r4[0])(x - r4[2]) |
; 202  : 
; 203  : 	s.m128d_f64[0] = q1[0];
; 204  : 	s.m128d_f64[1] = q2[0];				//s = | q2[0] | q1[0] |
; 205  : 	s = _mm_mul_pd(s, w);				//s = | x*q2[0] | x * q1[0] |

	mulpd	xmm0, xmm3

; 206  : 
; 207  : 	t.m128d_f64[0] = q1[1];
; 208  : 	t.m128d_f64[1] = q2[1];				//t = | q2[1] | q1[1] |
; 209  : 	w = _mm_mul_pd(w, w);				//w = | x^2 | x^2 |

	mulpd	xmm3, xmm3

; 210  : 	s = _mm_add_pd(t, s);				//s = | x*q2[0] + q2[1] | x * q1[0] + q1[1] |

	addpd	xmm0, XMMWORD PTR __xmm@4031554e2e2f05a34048569bf41890b3
	mulpd	xmm2, xmm1

; 211  : 	w = _mm_add_pd(w, s);				//w = | x^2 + x*q2[0] + q2[1] | x^2 + x * q1[0] + q1[1] |

	addpd	xmm3, xmm0

; 212  : 	w = _mm_mul_pd(w, u);				//w = | (x - r4[1])(x - r4[3])(x^2 + x*q2[0] + q2[1]) | (x - r4[0])(x - r4[2])(x^2 + x * q1[0] + q1[1]) |

	mulpd	xmm3, xmm2

; 213  : 	w.m128d_f64[0] *= w.m128d_f64[1];	//w[0] = w[1]*w[0]

	movaps	xmm0, xmm3
	unpckhpd xmm0, xmm3
	mulsd	xmm0, xmm3

; 214  : 	w.m128d_f64[0] *= r8Magnitude;		//w[0] = r4Magnitude*w[0]

	mulsd	xmm0, QWORD PTR __real@3ef85dc4150da9f3
	movaps	XMMWORD PTR tv5584[esp+272], xmm0

; 279  : 		cout << sin(x) - factoredP8SinSIMD(x)

	movaps	xmm0, xmm4
	call	__libm_sse2_sin_precise
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	xmm1, xmm0
	subsd	xmm1, QWORD PTR tv5591[esp+272]
	subsd	xmm0, QWORD PTR tv5584[esp+272]
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	sub	esp, 20					; 00000014H
	movsd	QWORD PTR [esp+12], xmm1
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	inc	esi
	cmp	esi, 100				; 00000064H
	jl	$LL19@main
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

	push	0
	call	DWORD PTR __imp___time64
	add	esp, 4
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 284  : 	srand(time(NULL));

	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4

; 285  : 	x = ((double)rand() / (RAND_MAX));

	call	DWORD PTR __imp__rand

; 286  : 
; 287  : 	for (int test = 1; test < 4; test++) {

	mov	ecx, 1
	mov	DWORD PTR _test$1$[esp+272], ecx
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@40dfffc000000000
	movaps	XMMWORD PTR _w$2$[esp+272], xmm0
	npad	2
$LL22@main:

; 289  : 		cout << endl << "Time Trial: " << test << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0N@EOIGBEKF@Time?5Trial?3?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 290  : 
; 291  : 		// Machine sin(x).
; 292  : 		cout << "machine sin(x)" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0P@LOMHEPNH@machine?5sin?$CIx?$CJ?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4545[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4545[esp+284]
	mov	esi, eax
	mov	DWORD PTR _t1$2$[esp+288], edx
	call	__allmul
	movaps	xmm0, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	mov	DWORD PTR _t1$1$[esp+272], esi
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 289  : 		cout << endl << "Time Trial: " << test << endl;

	mov	esi, 1000000				; 000f4240H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR _t1$2$[esp+272], edx
$LL1407@main:
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 295  : 			x = sin(x);

	call	__libm_sse2_sin_precise
	sub	esi, 1
	jne	SHORT $LL1407@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4572[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4572[esp+284]
	mov	DWORD PTR $T776[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T776[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 298  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR _t1$1$[esp+276]
	push	ecx
	sbb	esi, DWORD PTR _t1$2$[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 298  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 299  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 300  : 			<< " nanoseconds" << std::endl;
; 301  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 302  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 303  : 
; 304  : 		// Horner's method c++.
; 305  : 		cout << endl << "horner's method c++" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BE@IIJBFDGH@horner?8s?5method?5c?$CL?$CL?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4607[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4607[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T764[esp+288], edx
	call	__allmul
	movaps	xmm1, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	movsd	xmm2, QWORD PTR __real@3ef85dc4150da9f3

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T764[esp+272], edx
	movsd	xmm3, QWORD PTR __real@3f332321388fc9b8
	movsd	xmm4, QWORD PTR __real@3f2ccaf9ebd98c0b
	movsd	xmm5, QWORD PTR __real@3f806b15f3ef65c3
	movsd	xmm6, QWORD PTR __real@3f324f5d7fa558bc
	movsd	xmm7, QWORD PTR __real@3fc55a0fd0f46665
	mov	DWORD PTR $T787[esp+272], esi
	npad	1
$LL28@main:
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 15   : 		y = c[i] + x*y;

	movaps	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@0000000000000000
	addsd	xmm0, xmm2
	mulsd	xmm0, xmm1
	subsd	xmm0, xmm3
	mulsd	xmm0, xmm1
	addsd	xmm0, xmm4
	mulsd	xmm0, xmm1
	addsd	xmm0, xmm5
	mulsd	xmm0, xmm1
	addsd	xmm0, xmm6
	mulsd	xmm0, xmm1
	subsd	xmm0, xmm7
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3f04a8fb9dce943e
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3feffff65b43d273
	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3e81a8bd333aee92

; 306  : 		t1 = Clock::now();
; 307  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	SHORT $LL28@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4666[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4666[esp+284]
	mov	DWORD PTR $T774[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T774[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 311  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T787[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T764[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 311  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 312  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 313  : 			<< " nanoseconds" << std::endl;
; 314  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 315  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 316  : 
; 317  : 		// unrolled p4 horners method in c++.
; 318  : 		cout << endl << "unrolled p4 horners method in c++" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0CC@IKFEIJOO@unrolled?5p4?5horners?5method?5in?5c?$CL@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4701[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4701[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T763[esp+288], edx
	call	__allmul
	movaps	xmm1, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	movsd	xmm2, QWORD PTR __real@3fa30d19d8575fff

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T763[esp+272], edx
	movsd	xmm3, QWORD PTR __real@3f5585088804c979
	movsd	xmm4, QWORD PTR __real@3fcdeceea9321d76
	movsd	xmm5, QWORD PTR __real@3fabe3733ad470ca
	movsd	xmm6, QWORD PTR __real@3fef7177f65ab3d7
	mov	DWORD PTR $T786[esp+272], esi
	npad	10
$LL31@main:
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 58   : 	y = c4[1] + x*y;

	movaps	xmm0, xmm1
	mulsd	xmm0, xmm2
	subsd	xmm0, xmm4

; 59   : 	y = c4[2] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, xmm5

; 60   : 	y = c4[3] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, xmm6

; 61   : 	y = c4[4] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, xmm3

; 319  : 		t1 = Clock::now();
; 320  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	SHORT $LL31@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4728[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4728[esp+284]
	mov	DWORD PTR $T773[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T773[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 324  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T786[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T763[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 324  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 325  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 326  : 			<< " nanoseconds" << std::endl;
; 327  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 328  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 329  : 
; 330  : 		// unrolled p8 horners method in c++.
; 331  : 		cout << endl << "unrolled p8 horners method in c++" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0CC@DBFPCLAP@unrolled?5p8?5horners?5method?5in?5c?$CL@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4763[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4763[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T762[esp+288], edx
	call	__allmul
	movaps	xmm1, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	movsd	xmm2, QWORD PTR __real@3ef85dc4150da9f3

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T762[esp+272], edx
	movsd	xmm3, QWORD PTR __real@3f332321388fc9b8
	movsd	xmm4, QWORD PTR __real@3f2ccaf9ebd98c0b
	movsd	xmm5, QWORD PTR __real@3f806b15f3ef65c3
	movsd	xmm6, QWORD PTR __real@3f324f5d7fa558bc
	movsd	xmm7, QWORD PTR __real@3fc55a0fd0f46665
	mov	DWORD PTR $T785[esp+272], esi
	npad	10
$LL34@main:
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 96   : 	y = c8[1] + x*y;

	movaps	xmm0, xmm1
	mulsd	xmm0, xmm2
	subsd	xmm0, xmm3

; 97   : 	y = c8[2] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, xmm4

; 98   : 	y = c8[3] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, xmm5

; 99   : 	y = c8[4] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, xmm6

; 100  : 	y = c8[5] + x*y;

	mulsd	xmm0, xmm1
	subsd	xmm0, xmm7

; 101  : 	y = c8[6] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3f04a8fb9dce943e

; 102  : 	y = c8[7] + x*y;

	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3feffff65b43d273

; 103  : 	y = c8[8] + x*y;

	mulsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3e81a8bd333aee92

; 332  : 		t1 = Clock::now();
; 333  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	SHORT $LL34@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4790[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4790[esp+284]
	mov	DWORD PTR $T772[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T772[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 337  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T785[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T762[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 337  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 338  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 339  : 			<< " nanoseconds" << std::endl;
; 340  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 341  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 342  : 
; 343  : 		// factored quartic in c++.
; 344  : 		cout << endl << "factored quartic in c++" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BI@BBMOCOEL@factored?5quartic?5in?5c?$CL?$CL?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4825[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4825[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T761[esp+288], edx
	call	__allmul
	movaps	xmm2, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	movsd	xmm3, QWORD PTR __real@3fa30d19d8575fff

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 100000				; 000186a0H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T761[esp+272], edx
	movsd	xmm4, QWORD PTR __real@4013786cd7d05568
	movsd	xmm5, QWORD PTR __real@bffb9dbcb6b90958
	movsd	xmm6, QWORD PTR __real@400924b8343e6ef4
	movsd	xmm7, QWORD PTR __real@bf55e6ffd208d315
	mov	DWORD PTR $T784[esp+272], esi
	npad	6
$LL37@main:
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 147  : 	return r4Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3]);

	movaps	xmm1, xmm2
	movaps	xmm0, xmm2
	subsd	xmm1, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm1, xmm3
	mulsd	xmm1, xmm0
	movaps	xmm0, xmm2
	subsd	xmm0, xmm5
	subsd	xmm2, xmm7
	mulsd	xmm1, xmm0
	mulsd	xmm1, xmm2
	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	subsd	xmm2, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm2, xmm3
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm1
	subsd	xmm0, xmm5
	subsd	xmm1, xmm7
	mulsd	xmm2, xmm0
	mulsd	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm0, xmm2
	subsd	xmm1, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm1, xmm3
	mulsd	xmm1, xmm0
	movaps	xmm0, xmm2
	subsd	xmm0, xmm5
	subsd	xmm2, xmm7
	mulsd	xmm1, xmm0
	mulsd	xmm1, xmm2
	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	subsd	xmm2, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm2, xmm3
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm1
	subsd	xmm0, xmm5
	subsd	xmm1, xmm7
	mulsd	xmm2, xmm0
	mulsd	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm0, xmm2
	subsd	xmm1, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm1, xmm3
	mulsd	xmm1, xmm0
	movaps	xmm0, xmm2
	subsd	xmm0, xmm5
	subsd	xmm2, xmm7
	mulsd	xmm1, xmm0
	mulsd	xmm1, xmm2
	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	subsd	xmm2, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm2, xmm3
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm1
	subsd	xmm0, xmm5
	subsd	xmm1, xmm7
	mulsd	xmm2, xmm0
	mulsd	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm0, xmm2
	subsd	xmm1, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm1, xmm3
	mulsd	xmm1, xmm0
	movaps	xmm0, xmm2
	subsd	xmm0, xmm5
	subsd	xmm2, xmm7
	mulsd	xmm1, xmm0
	mulsd	xmm1, xmm2
	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	subsd	xmm2, xmm4
	mulsd	xmm2, xmm3
	subsd	xmm0, xmm6
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm1
	subsd	xmm0, xmm5
	subsd	xmm1, xmm7
	mulsd	xmm2, xmm0
	mulsd	xmm2, xmm1
	movaps	xmm1, xmm2
	movaps	xmm0, xmm2
	subsd	xmm1, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm1, xmm3
	mulsd	xmm1, xmm0
	movaps	xmm0, xmm2
	subsd	xmm0, xmm5
	subsd	xmm2, xmm7
	mulsd	xmm1, xmm0
	mulsd	xmm1, xmm2
	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	subsd	xmm2, xmm4
	subsd	xmm0, xmm6
	mulsd	xmm2, xmm3
	mulsd	xmm2, xmm0
	movaps	xmm0, xmm1
	subsd	xmm0, xmm5
	subsd	xmm1, xmm7
	mulsd	xmm2, xmm0
	mulsd	xmm2, xmm1

; 345  : 		t1 = Clock::now();
; 346  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	$LL37@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4891[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4891[esp+284]
	mov	DWORD PTR $T771[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T771[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 350  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T784[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T761[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 350  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 351  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 352  : 			<< " nanoseconds" << std::endl;
; 353  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 354  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 355  : 
; 356  : 		// factored p_8 in c++.
; 357  : 		cout << endl << "factored p_8 in c++" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BE@GGKOCPJD@factored?5p_8?5in?5c?$CL?$CL?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4926[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4926[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T760[esp+288], edx
	call	__allmul
	movaps	xmm4, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	mov	DWORD PTR $T783[esp+272], esi

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T760[esp+272], edx
$LL40@main:
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 180  : 	return r8Magnitude*(x - r4[0])*(x - r4[1])*(x - r4[2])*(x - r4[3])*(x*x + q1[0] * x + q1[1])*(x*x + q2[0] * x + q2[1]);

	movaps	xmm3, xmm4
	movaps	xmm0, xmm4
	movaps	xmm2, xmm4
	mulsd	xmm2, xmm4
	subsd	xmm3, QWORD PTR __real@401794f1820e7d64
	subsd	xmm0, QWORD PTR __real@400921fb65ed6164
	movaps	xmm1, xmm2
	mulsd	xmm3, QWORD PTR __real@3ef85dc4150da9f3
	mulsd	xmm3, xmm0
	movaps	xmm0, xmm4
	subsd	xmm0, QWORD PTR __real@c00607e7cce90ccf
	mulsd	xmm3, xmm0
	movaps	xmm0, xmm4
	subsd	xmm0, QWORD PTR __real@be81a8c2850e8406
	mulsd	xmm3, xmm0
	movaps	xmm0, xmm4
	mulsd	xmm0, QWORD PTR __real@402a3cad4dae3fc8
	mulsd	xmm4, QWORD PTR __real@401b575f52239c9d
	subsd	xmm1, xmm0
	addsd	xmm4, xmm2
	addsd	xmm1, QWORD PTR __real@4048569bf41890b3
	addsd	xmm4, QWORD PTR __real@4031554e2e2f05a3
	mulsd	xmm3, xmm1
	mulsd	xmm4, xmm3

; 358  : 		t1 = Clock::now();
; 359  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	$LL40@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4960[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4960[esp+284]
	mov	DWORD PTR $T770[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T770[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 363  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T783[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T760[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 363  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 364  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 365  : 			<< " nanoseconds" << std::endl;
; 366  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 367  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 368  : 
; 369  : 		// Horner's method with intrinsics.
; 370  : 		cout << endl << "horner's method with asm intrinsics" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0CE@KPFAJFKC@horner?8s?5method?5with?5asm?5intrins@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv4995[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv4995[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T759[esp+288], edx
	call	__allmul
	movaps	xmm2, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	mov	DWORD PTR $T782[esp+272], esi

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	ecx, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T759[esp+272], edx
	npad	11
$LL43@main:
	movaps	xmm3, XMMWORD PTR __xmm@bf332321388fc9b83ef85dc4150da9f3
	movaps	xmm4, xmm2
	unpcklpd xmm4, xmm4
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 31   : 	for (int i = 2; i < (length - 1); i += 2) {

	mov	eax, 2
	mulpd	xmm4, xmm4
	npad	9
$LL710@main:

; 32   : 		v.m128d_f64[0] = c[i];

	movsd	xmm1, QWORD PTR _c8$[esp+eax*8+272]

; 33   : 		v.m128d_f64[1] = c[i + 1];				//v = | c[i+1] | c[i] |

	movsd	xmm0, QWORD PTR _c8$[esp+eax*8+280]
	add	eax, 2

; 35   : 		w = _mm_add_pd(v, w);					//w = | c[i+1] + x*w[1] | c[i] + x*w[0] |

	unpcklpd xmm1, xmm0
	mulpd	xmm3, xmm4
	addpd	xmm3, xmm1
	cmp	eax, 8
	jb	SHORT $LL710@main

; 36   : 	}
; 37   : 
; 38   : 	if ((length % 2) == 0) {
; 39   : 		w.m128d_f64[0] *= x;					//w = | w[1] | x*w[0] |
; 40   : 	}
; 41   : 	else {
; 42   : 		u.m128d_f64[0] = x*x;

	movaps	xmm0, xmm2
	mulsd	xmm0, xmm2

; 43   : 		u.m128d_f64[1] = x;						//u = | x | x^2 |
; 44   : 		w = _mm_mul_pd(u, w);					//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm0, xmm2
	mulpd	xmm3, xmm0
	movaps	XMMWORD PTR _w$791[esp+272], xmm3

; 45   : 		w.m128d_f64[0] += c[length - 1];		//w = | w[1] | c[n] + w[0] |

	addsd	xmm3, QWORD PTR __real@3e81a8bd333aee92
	movsd	QWORD PTR _w$791[esp+272], xmm3

; 46   : 	}
; 47   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm2, XMMWORD PTR _w$791[esp+272]
	haddpd	xmm2, xmm2

; 371  : 		t1 = Clock::now();
; 372  : 		for (int n = 0; n < iterations; n++) {

	sub	ecx, 1
	jne	SHORT $LL43@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5032[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5032[esp+284]
	mov	DWORD PTR $T769[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T769[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 376  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T782[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T759[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 376  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 377  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 378  : 			<< " nanoseconds" << std::endl;
; 379  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 380  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 381  : 
; 382  : 		// unrolled p4 horners method with asm intrinsics.
; 383  : 		cout << endl << "unrolled p4 horners method with asm intrinsics" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0CP@EBAENJH@unrolled?5p4?5horners?5method?5with?5@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5067[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5067[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T758[esp+288], edx
	call	__allmul
	movaps	xmm2, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	mov	DWORD PTR $T781[esp+272], esi

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T758[esp+272], edx
	npad	2
$LL46@main:
	movaps	xmm1, XMMWORD PTR __xmm@bfcdeceea9321d763fa30d19d8575fff
	movaps	xmm0, xmm2
	unpcklpd xmm0, xmm0
	mulpd	xmm0, xmm0
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 76   : 	w = _mm_mul_pd(u, v);						//w = | (x^2)*c[1] | (x^2)*c[0] |

	mulpd	xmm1, xmm0

; 80   : 	u.m128d_f64[0] = x*x;

	movaps	xmm0, xmm2
	mulsd	xmm0, xmm2
	addpd	xmm1, XMMWORD PTR __xmm@3fef7177f65ab3d73fabe3733ad470ca

; 81   : 	u.m128d_f64[1] = x;							//u = | x | x^2 |
; 82   : 	w = _mm_mul_pd(u, w);						//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm0, xmm2
	mulpd	xmm1, xmm0
	movaps	XMMWORD PTR _w$790[esp+272], xmm1

; 83   : 	w.m128d_f64[0] += c4[4];					//w = | w[1] | c[n] + w[0] |

	addsd	xmm1, QWORD PTR __real@3f5585088804c979
	movsd	QWORD PTR _w$790[esp+272], xmm1

; 84   : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$790[esp+272]
	haddpd	xmm0, xmm0

; 85   : 
; 86   : 	return w.m128d_f64[0];

	movaps	xmm2, xmm0

; 384  : 		t1 = Clock::now();
; 385  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	SHORT $LL46@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5101[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5101[esp+284]
	mov	DWORD PTR $T768[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T768[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 389  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T781[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T758[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 389  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 390  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 391  : 			<< " nanoseconds" << std::endl;
; 392  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 393  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 394  : 
; 395  : 		// unrolled p8 horners method with asm intrinsics.
; 396  : 		cout << endl << "unrolled p8 horners method with asm intrinsics" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0CP@LGOFLGFG@unrolled?5p8?5horners?5method?5with?5@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5136[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5136[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T757[esp+288], edx
	call	__allmul
	movaps	xmm2, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	mov	DWORD PTR $T780[esp+272], esi

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T757[esp+272], edx
	npad	1
$LL49@main:
	movaps	xmm1, XMMWORD PTR __xmm@bf332321388fc9b83ef85dc4150da9f3
	movaps	xmm0, xmm2
	unpcklpd xmm0, xmm0
	mulpd	xmm0, xmm0
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 118  : 	w = _mm_mul_pd(u, v);						//w = | (x^2)*c[1] | (x^2)*c[0] |

	mulpd	xmm1, xmm0

; 119  : 	v.m128d_f64[0] = c8[2];
; 120  : 	v.m128d_f64[1] = c8[3];						//v = | c[3] | c[2] |
; 121  : 	w = _mm_add_pd(w, v);						//w = | c[3] + (x^2)*c[1] | c[2] + (x^2)*c[0] |

	addpd	xmm1, XMMWORD PTR __xmm@3f806b15f3ef65c33f2ccaf9ebd98c0b

; 122  : 
; 123  : 	w = _mm_mul_pd(u, w);						//w = | (x^2)*(c[3] + (x^2)*c[1]) | (x^2)*(c[2] + (x^2)*c[0]) |

	mulpd	xmm1, xmm0

; 124  : 	v.m128d_f64[0] = c8[4];
; 125  : 	v.m128d_f64[1] = c8[5];						//v = | c[5] | c[6] |
; 126  : 	w = _mm_add_pd(w, v);						//w = | c[5] + (x^2)*(c[3] + (x^2)*c[1]) | c[6] + (x^2)*(c[2] + (x^2)*c[0]) |

	addpd	xmm1, XMMWORD PTR __xmm@bfc55a0fd0f466653f324f5d7fa558bc

; 127  : 
; 128  : 	w = _mm_mul_pd(u, w);

	mulpd	xmm1, xmm0

; 132  : 
; 133  : 	u.m128d_f64[0] = x*x;

	movaps	xmm0, xmm2
	mulsd	xmm0, xmm2
	addpd	xmm1, XMMWORD PTR __xmm@3feffff65b43d2733f04a8fb9dce943e

; 134  : 	u.m128d_f64[1] = x;							//u = | x | x^2 |
; 135  : 	w = _mm_mul_pd(u, w);						//w = | x*w[1] | (x^2)*w[0] |

	unpcklpd xmm0, xmm2
	mulpd	xmm1, xmm0
	movaps	XMMWORD PTR _w$789[esp+272], xmm1

; 136  : 	w.m128d_f64[0] += c8[8];					//w = | w[1] | c[n] + w[0] |

	addsd	xmm1, QWORD PTR __real@3e81a8bd333aee92
	movsd	QWORD PTR _w$789[esp+272], xmm1

; 137  : 	w = _mm_hadd_pd(w, w);						//w = | w[0]+w[1] | w[0]+w[1] |

	movaps	xmm0, XMMWORD PTR _w$789[esp+272]
	haddpd	xmm0, xmm0

; 138  : 
; 139  : 	return w.m128d_f64[0];

	movaps	xmm2, xmm0

; 397  : 		t1 = Clock::now();
; 398  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	SHORT $LL49@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5172[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5172[esp+284]
	mov	DWORD PTR $T767[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T767[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 402  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T780[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T757[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 402  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 403  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 404  : 			<< " nanoseconds" << std::endl;
; 405  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 406  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 407  : 
; 408  : 		// factored quartic intrinsics.
; 409  : 		cout << endl << "factored quartic with intrinsics" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0CB@IJPEMKEN@factored?5quartic?5with?5intrinsics@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5209[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5209[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T756[esp+288], edx
	call	__allmul
	movaps	xmm2, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	movsd	xmm3, QWORD PTR __real@400924b8343e6ef4

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T756[esp+272], edx
	movsd	xmm4, QWORD PTR __real@bf55e6ffd208d315
	mov	DWORD PTR $T779[esp+272], esi
	npad	9
$LL52@main:
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 164  : 	u = _mm_sub_pd(w, u);				//u = | x - r4[1] | x - r4[0] |

	movsd	xmm0, QWORD PTR __real@4013786cd7d05568
	unpcklpd xmm2, xmm2
	unpcklpd xmm0, xmm3
	movaps	xmm1, xmm2
	subpd	xmm1, xmm0

; 165  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	movsd	xmm0, QWORD PTR __real@bffb9dbcb6b90958
	unpcklpd xmm0, xmm4
	subpd	xmm2, xmm0

; 166  : 	w = _mm_mul_pd(u, v);				//u = | (x - r4[1])(x - r4[3]) | (x - r4[0])(x - r4[2]) |

	mulpd	xmm2, xmm1

; 167  : 	w.m128d_f64[0] *= w.m128d_f64[1];	//w[0] = (x - r4[1])(x - r4[3])(x - r4[0])(x - r4[2])

	movaps	xmm0, xmm2
	unpckhpd xmm0, xmm2
	mulsd	xmm2, xmm0

; 168  : 	w.m128d_f64[0] *= r4Magnitude;		//w[0] = r4Magnitude*(x - r4[1])(x - r4[3])(x - r4[0])(x - r4[2])

	mulsd	xmm2, QWORD PTR __real@3fa30d19d8575fff

; 410  : 		t1 = Clock::now();
; 411  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	SHORT $LL52@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5246[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5246[esp+284]
	mov	DWORD PTR $T766[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T766[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 415  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T779[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T756[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 415  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 416  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 417  : 			<< " nanoseconds" << std::endl;
; 418  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 419  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 420  : 
; 421  : 		// factored p_8 SIMD intrinsics.
; 422  : 		cout << endl << "factored p_8 intrinsics" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	edx, OFFSET ??_C@_0BI@KNMALJAH@factored?5p_8?5intrinsics?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5287[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5287[esp+284]
	mov	esi, eax
	mov	DWORD PTR $T755[esp+288], edx
	call	__allmul
	movaps	xmm3, XMMWORD PTR _w$2$[esp+272]

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	movsd	xmm4, QWORD PTR __real@400921fb65ed6164

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	eax, 1000000				; 000f4240H

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	DWORD PTR $T755[esp+272], edx
	mov	DWORD PTR $T778[esp+272], esi
	npad	7
$LL55@main:
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 200  : 	v = _mm_sub_pd(w, v);				//v = | x - r4[3] | x - r4[2] |

	movsd	xmm2, QWORD PTR __real@be81a8c2850e8406
	movsd	xmm0, QWORD PTR __real@c00607e7cce90ccf
	unpcklpd xmm0, xmm2
	unpcklpd xmm3, xmm3
	movaps	xmm1, xmm3
	movaps	xmm2, xmm3
	subpd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@401794f1820e7d64
	unpcklpd xmm0, xmm4
	subpd	xmm2, xmm0
	movaps	xmm0, XMMWORD PTR __xmm@401b575f52239c9dc02a3cad4dae3fc8

; 201  : 	u = _mm_mul_pd(u, v);				//u = | (x - r4[1])(x - r4[3]) | (x - r4[0])(x - r4[2]) |
; 202  : 
; 203  : 	s.m128d_f64[0] = q1[0];
; 204  : 	s.m128d_f64[1] = q2[0];				//s = | q2[0] | q1[0] |
; 205  : 	s = _mm_mul_pd(s, w);				//s = | x*q2[0] | x * q1[0] |

	mulpd	xmm0, xmm3

; 206  : 
; 207  : 	t.m128d_f64[0] = q1[1];
; 208  : 	t.m128d_f64[1] = q2[1];				//t = | q2[1] | q1[1] |
; 209  : 	w = _mm_mul_pd(w, w);				//w = | x^2 | x^2 |

	mulpd	xmm3, xmm3

; 210  : 	s = _mm_add_pd(t, s);				//s = | x*q2[0] + q2[1] | x * q1[0] + q1[1] |

	addpd	xmm0, XMMWORD PTR __xmm@4031554e2e2f05a34048569bf41890b3
	mulpd	xmm2, xmm1

; 211  : 	w = _mm_add_pd(w, s);				//w = | x^2 + x*q2[0] + q2[1] | x^2 + x * q1[0] + q1[1] |

	addpd	xmm3, xmm0

; 212  : 	w = _mm_mul_pd(w, u);				//w = | (x - r4[1])(x - r4[3])(x^2 + x*q2[0] + q2[1]) | (x - r4[0])(x - r4[2])(x^2 + x * q1[0] + q1[1]) |

	mulpd	xmm3, xmm2

; 213  : 	w.m128d_f64[0] *= w.m128d_f64[1];	//w[0] = w[1]*w[0]

	movaps	xmm0, xmm3
	unpckhpd xmm0, xmm3
	mulsd	xmm3, xmm0

; 214  : 	w.m128d_f64[0] *= r8Magnitude;		//w[0] = r4Magnitude*w[0]

	mulsd	xmm3, QWORD PTR __real@3ef85dc4150da9f3

; 423  : 		t1 = Clock::now();
; 424  : 		for (int n = 0; n < iterations; n++) {

	sub	eax, 1
	jne	SHORT $LL55@main
	movaps	XMMWORD PTR _w$2$[esp+272], xmm3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[esp+272], edi
	mov	DWORD PTR __Freq$1$[esp+272], esi

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv5363[esp+288], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[esp+272]
	push	DWORD PTR __Freq$2$[esp+276]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv5363[esp+284]
	mov	DWORD PTR $T765[esp+288], eax
	mov	esi, edx
	call	__allmul

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T765[esp+272]
	add	edi, eax
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 428  : 		std::cout << "time: "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T778[esp+276]
	push	ecx
	sbb	esi, DWORD PTR $T755[esp+280]
; File c:\cs\cpp\sinapprox\sinapprox\sinapprox.cpp

; 428  : 		std::cout << "time: "

	mov	edx, OFFSET ??_C@_06IEGNHKAC@time?3?5?$AA@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	esi
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	edx, OFFSET ??_C@_0N@KBFONPHA@?5nanoseconds?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 429  : 			<< std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count()
; 430  : 			<< " nanoseconds" << std::endl;
; 431  : 		cout << "ns/f(x): "

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	sub	esp, 12					; 0000000cH
	mov	edx, OFFSET ??_C@_09JBFKNNHK@ns?1f?$CIx?$CJ?3?5?$AA@
	movsd	QWORD PTR [esp+4], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	ecx, DWORD PTR _test$1$[esp+272]
	inc	ecx
	mov	DWORD PTR _test$1$[esp+272], ecx
	cmp	ecx, 4
	jl	$LL22@main

; 432  : 			<< (double)std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() / iterations << endl;
; 433  : 	}
; 434  : 
; 435  : 	return 0;
; 436  : 
; 437  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+272]
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 244  : 		{	// construct from a duration

	push	ebp
	mov	ebp, esp

; 243  : 		: _MyDur(_Other)

	mov	edx, DWORD PTR __Other$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 245  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 135  : 		return (_MyRep);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 136  : 		}

	ret	0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 143  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 106  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 99   : 			: _Myostr(_Ostr)

	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [edi], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN6@sentry

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@sentry:

; 103  : 			}
; 104  : 
; 105  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 106  : 			{	// destroy after unlocking
; 107  : 			if (_Myostr.rdbuf() != 0)
; 108  : 				_Myostr.rdbuf()->_Unlock();
; 109  : 			}
; 110  : 
; 111  : 		_Myt& _Myostr;	// the output stream, for _Unlock call at destruction
; 112  : 
; 113  : 	private:
; 114  : 		_Sentry_base& operator=(const _Sentry_base&);
; 115  : 		};
; 116  : 
; 117  : 	class sentry
; 118  : 		: public _Sentry_base
; 119  : 		{	// stores thread lock and state of stream
; 120  : 	public:
; 121  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Ostr)
; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+esi+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN2@sentry
	mov	ecx, DWORD PTR [eax+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN2@sentry:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 127  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 99   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi

; 100  : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 117  : 		{	// construct from representation

	push	ebp
	mov	ebp, esp

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 118  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__Pad$ = -48						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
$T19 = -32						; size = 1
$T13 = -28						; size = 1
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 780  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, edx
	mov	DWORD PTR __Val$1$[ebp], eax
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 783  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	jne	SHORT $LN26@operator
	xor	ecx, ecx
	jmp	SHORT $LN121@operator
$LN26@operator:
	mov	ecx, eax
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL108@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL108@operator
	sub	ecx, edx
$LN121@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	DWORD PTR __Count$2$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+ebx+36]
	mov	esi, DWORD PTR [eax+ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN110@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN110@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN110@operator:
	sub	esi, ecx
	sbb	edi, 0
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 99   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], ebx

; 100  : 			{	// lock the stream buffer, if there
; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN39@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN39@operator:

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ebx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN35@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [eax+ebx+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN35@operator
	cmp	ecx, ebx
	je	SHORT $LN35@operator

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN35@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+ebx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 786  : 		? 0 : _Ostr.width() - _Count;
; 787  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 788  : 
; 789  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

	mov	ecx, 4

; 791  : 	else

	jmp	$LN22@operator
$LN8@operator:

; 792  : 		{	// state okay, insert
; 793  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+ebx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN105@operator
	npad	2
$LL4@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN111@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN111@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T13[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN2@operator
$LN112@operator:

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

	mov	ecx, 4

; 800  : 					break;

	jmp	SHORT $LN6@operator
$LN2@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL4@operator
$LN3@operator:
	xor	ecx, ecx

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	jne	SHORT $LN6@operator
$LN105@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	0
	push	DWORD PTR __Count$2$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	DWORD PTR __Val$1$[ebp]
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN112@operator
	test	edx, edx
	jne	SHORT $LN112@operator
$LL114@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jl	SHORT $LN118@operator
	jg	SHORT $LN113@operator
	test	esi, esi
	je	SHORT $LN118@operator
$LN113@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T19[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T19[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN5@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

	xor	ecx, ecx
	or	ecx, 4

; 813  : 					break;

	jmp	SHORT $LN6@operator
$LN5@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL114@operator
$LN118@operator:
	xor	ecx, ecx
$LN6@operator:

; 814  : 					}
; 815  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
	jmp	SHORT $LN124@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 816  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
$LN124@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 817  : 		}
; 818  : 
; 819  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 130  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 133  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN88@operator
	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN88@operator:

; 106  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN115@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN115@operator:

; 820  : 	return (_Ostr);

	mov	eax, ebx

; 821  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 991  : 	{	// insert newline and flush stream

	push	ebp
	mov	ebp, esp
	push	esi

; 992  : 	_Ostr.put(_Ostr.widen('\n'));

	mov	esi, DWORD PTR __Ostr$[ebp]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	movzx	ecx, al
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 993  : 	_Ostr.flush();

	mov	ecx, esi
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 994  : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 995  : 	}

	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 847  : 	{	// add time_point to time_point

	push	ebp
	mov	ebp, esp

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	eax, DWORD PTR __Right$[ebp]

; 847  : 	{	// add time_point to time_point

	push	esi

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	sub	esi, DWORD PTR [eax]

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], esi

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sbb	edx, DWORD PTR [eax+4]

; 848  : 	return (_Left.time_since_epoch() - _Right.time_since_epoch());

	mov	eax, ecx

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], edx

; 849  : 	}

	pop	esi
	pop	ebp
	ret	0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z
_TEXT	SEGMENT
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Dur$ = edx

; 552  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 553  : 
; 554  : 	typedef typename _To::rep _ToRep;
; 555  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 556  : 	return (_CF::num == 1 && _CF::den == 1

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx

; 557  : 			? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 558  : 		: _CF::num != 1 && _CF::den == 1
; 559  : 			? static_cast<_To>(static_cast<_ToRep>(
; 560  : 				static_cast<_CR>(
; 561  : 					_Dur.count()) * static_cast<_CR>(_CF::num)))
; 562  : 		: _CF::num == 1 && _CF::den != 1
; 563  : 			? static_cast<_To>(static_cast<_ToRep>(
; 564  : 				static_cast<_CR>(_Dur.count())
; 565  : 					/ static_cast<_CR>(_CF::den)))
; 566  : 		: static_cast<_To>(static_cast<_ToRep>(
; 567  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 568  : 				/ static_cast<_CR>(_CF::den))));
; 569  : 	}

	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 257  : 		{	// get duration from epoch

	push	ebp
	mov	ebp, esp

; 258  : 		return (_MyDur);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 259  : 		}

	pop	ebp
	ret	4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 350  : 	{	// subtract two durations

	push	ebp
	mov	ebp, esp

; 351  : 	typedef typename common_type<
; 352  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	sub	esi, DWORD PTR [eax]

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], esi

; 351  : 	typedef typename common_type<
; 352  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sbb	edx, DWORD PTR [eax+4]
	mov	eax, ecx

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], edx

; 354  : 	}

	pop	esi
	pop	ebp
	ret	0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
END
